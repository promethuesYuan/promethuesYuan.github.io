<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[当我在学MySQL时我到底在学什么]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%BD%93%E6%88%91%E5%9C%A8%E5%AD%A6MySQL%E6%97%B6%E6%88%91%E5%88%B0%E5%BA%95%E5%9C%A8%E5%AD%A6%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[一点MySQL学习感想 因为软工大作业项目的缘故，所以最近自己在学习如何使用MySQL数据库。学了有几天了，都是在学习命令行下的一些操作，给我的直接感受和当时使用navicat的感觉差不多，觉得好像就是把图形化界面使用命令行来表示了而已啊。找来一篇SQL语言教程，发现其实二者是互通的嘛。那么问题来了，当我在学MySQL时我到底在学什么呢？ 在知乎上翻看跟数据库有关的话题，如何回答这个问题心中慢慢有了眉目。回顾这几天的学习，说白了就是学习如何使用这种数据库，而数据库的主要功能无非就是存储和查询。学习数据库不是目的，它只是做开发时必须要用到的工具。对于当时做爬虫项目而言，数据库更可以是发掘数据中潜藏价值的仓库。 所以先学好怎么使用，有兴趣再去深入研究数据库原理等相关知识吧。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记]]></title>
    <url>%2F2019%2F09%2F07%2Fmysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MySQL学习记录 MySQL安装这个部分在暑假实习时候已经安装成功，就没有多花时间在这个上面。但为什么当时没有学习使用MySQL呢….当时用了navicat图形化管理，到后来不还是得学，哎…. MySQL数据库相关操作创建在MySQL中，使用create database语句创建数据库，语法格式如下： CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt; [[DEFAULT] CHARACTER SET &lt;字符集名&gt;] [[DEFAULT] COLLATE &lt;校对规则名&gt;];语法说明： IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。 [DEFAULT] CHARACTER SET：指定数据库的默认字符集。 [DEFAULT] COLLATE：指定字符集的默认校对规则。 实例1 输入create database test_db语句， 即可创建一个名为test_db的数据库 实例2 创建一个数据库，名为test_db_char，默认字符集为utf8，默认校对规则为utf8_general_ci mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_chinese_ci; Query OK, 1 row affected (0.03 sec)查看show databases语句，可以查看所有用户范围内的数据库该语句可以加上后缀like, 用于匹配数据库名称, 后面所借数据库名需用’ ‘括起来。 实例 show databases like &apos;test_db&apos; 完全匹配查找名为test_db的数据库 show databases like &apos;%test%&apos; 查找数据库名称中含有test的所有数据库 show databases like &apos;db%&apos; 查找数据库名称中以db开头的所有数据库 show databases like &apos;%db&apos; 查找数据库名称中以db结尾的所有数据库修改修改数据库语法格式为： ALTER DATABASE [数据库名] { [ DEFAULT ] CHARACTER SET &lt;字符集名&gt; | [ DEFAULT ] COLLATE &lt;校对规则名&gt;}查看数据库的定义声明：show create database 数据库名 实例 mysql&gt; CREATE DATABASE test_db -&gt; DEFAULT CHARACTER SET gb2312 -&gt; DEFAULT COLLATE gb2312_chinese_ci; mysql&gt; SHOW CREATE DATABASE test_db;删除语法格式： DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt; &lt;数据库名&gt;：指定要删除的数据库名。 IF EXISTS：用于防止当数据库不存在时发生错误。 DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。 选择语法格式: use &lt;数据库名&gt;如何查看当前使用的是哪个数据库?有三条语句可以实现。 select database(); show table; status; 引擎设置默认引擎： SET default_storage_engine=&lt; 存储引擎名 &gt;InnoDB 是系统的默认引擎，支持可靠的事务处理。通过上述语句修改后，默认引擎可以改变，但是MySQL重启后，默认引擎依然是InnoDB。 MySQL常见数据类型在MySQL中常见的数据类型如下所示: 1) 整数类型 包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型 FLOAT 和 DOUBLE，定点数类型 DECIMAL。 2) 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 3) 字符串类型 包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 4) 二进制类型 包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 具体数据类型的讲解可以看这儿MySQL常见数据类型 MySQL表相关操作创建其语法格式为： CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];其中，[表定义选项]的格式为： &lt;列名1&gt; &lt;类型1&gt; [,…] &lt;列名n&gt; &lt;类型n&gt;实例 船舰一个员工表，结构如下。 字段名称 数据类型 备注 id INT(ll) 员工编号 name VARCHAR(25) 员工名称 deptld INT(ll) 所在部门编号 salary FLOAT 工资 mysql&gt; USE test_db; Database changed mysql&gt; CREATE TABLE tb_emp1 -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt; ); Query OK, 0 rows affected (0.37 sec)使用show tables语句查看数据表是否创建成功 查看DESCRIBE/DESC 语句可以查看表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法规则如下： DESCRIBE &lt;表名&gt;; 或简写成： DESC &lt;表名&gt;;SHOW CREATE TABLE语句可以用来显示创建表时的CREATE TABLE语句，语法格式如下： SHOW CREATE TABLE &lt;表名&gt;\G；修改常用的语法格式如下： ALTER TABLE &lt;表名&gt; [修改选项] 修改选项的语法格式如下： { ADD COLUMN &lt;列名&gt; &lt;类型&gt; | CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt; | ALTER COLUMN &lt;列名&gt; { SET DEFAULT &lt;默认值&gt; | DROP DEFAULT } | MODIFY COLUMN &lt;列名&gt; &lt;类型&gt; | DROP COLUMN &lt;列名&gt; | RENAME TO &lt;新表名&gt; }添加字段ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]；实例：在第一列添加int类型字段col1 mysql&gt; ALTER TABLE tb_emp1 -&gt; ADD COLUMN col1 INT FIRST; Query OK, 0 rows affected (0.94 sec) Records: 0 Duplicates: 0 Warnings: 0若无 first 或 after，则默认在最后一行添加新字段 修改字段类型ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;删除字段ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；修改字段名称ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；新数据类型指的是修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。 修改表名ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；删除语法格式如下： DROP TABLE [IF EXISTS] &lt;表名&gt; [ , &lt;表名1&gt; , &lt;表名2&gt;] …语法说明如下：1.&lt;表名&gt;：被删除的表名。DROP TABLE 语句可以同时删除多个表，用户必须拥有该命令的权限。2.表被删除时，所有的表数据和表定义会被取消，所以使用本语句要小心。3.表被删除时，用户在该表上的权限并不会自动被删除。4.参数IF EXISTS用于在删除前判断删除的表是否存在，加上该参数后，在删除表的时候，如果表不存在，SQL 语句可以顺利执行，但会发出警告（warning）。 MySQL键约束键约束感觉就是给一些键增加特定的标识，作为这个表的某一种标识的体现。 键约束一共有主键、外键、唯一约束。 主键定义&amp;作用：“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 创建语法： &lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]实例：id int(11) primary key，此时id即成为这个表的主键。 在定义完所有列之后，指定主键的语法格式为： [CONSTRAINT &lt;约束名&gt;] PRIMARY KEY [字段名]实例：primary key(id),此时id即成为这个表的主键。 创建复合主键： PRIMARY KEY [字段1，字段2，…,字段n]实例：primary key(id, deptId),此时id和deptId即成为这个表的复合主键。 修改表时添加主键： ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);实例：ALTER TABLE tb_emp2 ADD PRIMARY KEY(id);，此时添加id成为这个表的主键。 外键定义&amp;作用：MySQL 外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。 创建语法： [CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]实例：CONSTRAINT fk_emp_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id) 修改表时添加外键： ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt; FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);实例： mysql&gt; ALTER TABLE tb_emp2 -&gt; ADD CONSTRAINT fk_tb_dept1 -&gt; FOREIGN KEY(deptId) -&gt; REFERENCES tb_dept1(id);删除外键： ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;实例: mysql&gt; ALTER TABLE tb_emp2 -&gt; DROP FOREIGN KEY fk_tb_dept1;唯一约束定义&amp;作用： MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 创建语法： &lt;字段名&gt; &lt;数据类型&gt; UNIQUE添加唯一约束： ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;);实例： mysql&gt; ALTER TABLE tb_dept1 -&gt; ADD CONSTRAINT unique_name UNIQUE(name); 删除唯一约束： ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;检查约束具体语法: CHECK &lt;表达式&gt; 修改表时添加约束： ALTER TABLE tb_emp7 ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;) 删除约束: ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;; 默认值设置：&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;; 非空约束设置: &lt;字段名&gt; &lt;数据类型&gt; NOT NULL; 选择数据selectselect语句语法： SELECT {* | &lt;字段列名&gt;} [ FROM &lt;表 1&gt;, &lt;表 2&gt;… [WHERE &lt;表达式&gt; [GROUP BY &lt;group by definition&gt; [HAVING &lt;expression&gt; [{&lt;operator&gt; &lt;expression&gt;}…]] [ORDER BY &lt;order by definition&gt;] [LIMIT[&lt;offset&gt;,] &lt;row count&gt;] ]查询表中全部内容，具体格式： SELECT * FROM 表名;查询指定字段，具体格式： SELECT &lt; 列名 &gt; FROM &lt; 表名 &gt;;去重消除重复的记录值，使用关键字distinct,具体语法: SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;;限制查询条数当只需要查询某几行内容时，需要用到关键字llimit，具体格式: &lt;LIMIT&gt; [&lt;位置偏移量&gt;,] &lt;行数&gt;实例1： SELECT * FROM tb_students_info LIMIT 4; 查询的就是1~4行的内容实例2： SELECT * FROM tb_students_info LIMIT 3,5; 查询的就是偏移3行，即4~8行的内容 排序具体格式： ORDER BY {&lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt;} [ASC|DESC]注:关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值。这两个关键字必须位于对应的列名、表达式、列的位置之后。 实例1： SELECT * FROM tb_students_info ORDER BY height;以height为升序排序 实例2： SELECT name,height FROM tb_student_info ORDER BY height DESC,name ASC;先以height为降序排序，然后以name为升序排序 条件查询筛选数据，具体格式： WHERE &lt;查询条件&gt; {&lt;判定运算1&gt;，&lt;判定运算2&gt;，…}判断语法如下:&lt;表达式1&gt;{=|&lt;|&lt;=|&gt;|&gt;=|&lt;=&gt;|&lt;&gt;|！=}&lt;表达式2&gt;&lt;表达式1&gt;[NOT]LIKE&lt;表达式2&gt;&lt;表达式1&gt;[NOT][REGEXP|RLIKE]&lt;表达式2&gt;&lt;表达式1&gt;[NOT]BETWEEN&lt;表达式2&gt;AND&lt;表达式3&gt;&lt;表达式1&gt;IS[NOT]NULL 插入数据]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++解题时的使用技巧]]></title>
    <url>%2F2019%2F09%2F03%2FC-%E8%A7%A3%E9%A2%98%E6%97%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[记录使用C++做CSP题目时用到的一些C中没用过的数据结构和算法 快排sort用法 头文件 #includesort函数可以有两个参数，也可以有三个参数： 排序数组起始位置 排序数组结束为止 排序的方法，确认是升序还是降序，默认缺省情况为升序排序 举例123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;int main()&#123; int a[20]=&#123;2,4,1,23,5,76,0,43,24,65&#125;,i; for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+20); for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; 注意sort函数第二个参数的范围。 下面主要举例讲解三个参数用来解决结构数组排序的问题。 在CSP 17-3-2排队问题中，我用了一个结构体来表示每个同学，其中包含他的学号和位置。我需要sort函数来对他们的位置进行排序，这个时候就需要用到带有三个参数的sort函数了。 结构体声明如下 1234typedef struct stu&#123; int id; int place;&#125;stu; 第三个参数函数声明如下 1234bool cmp(stu a, stu b)&#123; return a.place &lt; b.place;&#125; 因为我是要对他们的位置进行排序，而且是升序排序。通过修改return 的内容，可以实现对其他方面的排序以及修改排序的升降。 使用方法 1sort(array+1, array+1+n, cmp); 这样就能对结构数组其中的位置信息进行排序了。 栈和队列stack模板类定义在#include中定义示例代码：stack&lt;int&gt; s基本操作如下 操作 作用 s.push(x) 入栈 s.pop() 出栈，注意该操作只删除元素，不返回元素 s.top() 访问栈顶 s.empty() 栈是否为空，为空时返回true s.size() 访问栈的元素个数 queue模板类定义在#include中定义示例代码：queue&lt;int&gt; q基本操作如下 操作 作用 q.push(x) 入队 q.pop() 出队，弹出队列第一个元素，但不会返回其值 q.front() 访问队首元素，即第一个入队的 q.back() 访问队尾元素，即最后一个入队的 q.empty() 判断队空，若为空返回true q.size() 访问队元素个数 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;void stackFunction()&#123; stack&lt;int&gt; s; //入栈 s.push(1); s.push(2); s.push(3); //栈元素个数 cout&lt;&lt;"size of stack:"&lt;&lt;s.size()&lt;&lt;endl; //栈顶元素 cout&lt;&lt;"top of stack:"&lt;&lt;s.top()&lt;&lt;endl; //出栈 s.pop(); cout&lt;&lt;"after pop, top of stack is:"&lt;&lt;s.top()&lt;&lt;endl; //栈空 if(!s.empty()) cout&lt;&lt;"stack is not empty"&lt;&lt;endl; s.pop(); s.pop(); if(s.empty() ) cout&lt;&lt;"stack is empty now"&lt;&lt;endl;&#125;void queueFunction()&#123; queue&lt;int&gt; q; //入队 q.push(1); q.push(2); q.push(3); //队首元素 cout&lt;&lt;"front of queue:"&lt;&lt;q.front()&lt;&lt;endl; //队尾元素 cout&lt;&lt;"back of queue:"&lt;&lt;q.back()&lt;&lt;endl; //队长度 cout&lt;&lt;"size of queue:"&lt;&lt;q.size()&lt;&lt;endl; //出队 q.pop(); cout&lt;&lt;"after pop, front of queue is:"&lt;&lt;q.front()&lt;&lt;endl; //队空 if(!q.empty()) cout&lt;&lt;"queue is not empty"&lt;&lt;endl; q.pop(); q.pop(); if(q.empty() ) cout&lt;&lt;"queue is empty now"&lt;&lt;endl;&#125; int main()&#123; stackFunction(); cout&lt;&lt;endl; queueFunction(); cout&lt;&lt;endl; return 0;&#125; 结果 123456789101112size of stack:3top of stack:3after pop, top of stack is:2stack is not emptystack is empty nowfront of queue:1back of queue:3size of queue:3after pop, front of queue is:2queue is not emptyqueue is empty now]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++, CSP, 数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2019%2F09%2F01%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一直说是要学习Git，但总是一拖再拖。花了不到一天的时间，就把廖老师的Git教程学完了，受益匪浅，接下来可以在GitHub玩耍了233。顺便掌握了一些windows命令行操作，也很有用。 Git的第一步——创建版本库创建版本库 1234567891011$ mkdir &lt;repository name&gt;$ cd &lt;repository name&gt;创建一个目录$ git init （创建一个版本库）Initialized empty Git repository in &lt;当前路径&gt;.git/添加文件到Git仓库，分两步:$ git add &lt;file name&gt;$ git commit -m &lt;message&gt;可以先多次添加，最后一次提交 版本控制版本回退 123456789$ git log$ git log --pretty=oneline显示从最近到最远的提交日志$ git reset --hard HEAD~&lt;num&gt;(往前num个版本)$ git reset --hard &lt;commit id&gt;(前往对应的提交版本)修改HEAD指向的版本，HEAD指向的版本就是当前版本$ git reflog 查看命令历史，以便确定要回到未来的哪个版本 工作区和暂存区 1$ git status 常看状态 管理修改 12$git diff HEAD -- &lt;file name&gt;查看工作区和版本库里面最新版本的区别 撤销修改 12345$ git checkout -- file总之，就是让这个文件回到最近一次git commit或git add时的状态$ git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区 删除文件 1234情况一：将版本库中的删除$ git rm删掉，并且git commit情况二：误删除，需要恢复到版本库中$ git checkout -- test.txt 远程仓库添加远程仓库 12345678$ git remote add origin git@github.com:michaelliao/learngit.git连接远程仓库，github.com：后面接的是自己需要关联的仓库$ git push -u origin master将本地内容推到远程仓库第一次推送master分支的所有内容的命令行需要带 -u此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 从远程仓库克隆到本地 12$ git clone git@github.com:michaelliao/gitskills.git从远程仓库克隆到当前目录下，同样的，github.com：后面接的是自己需要克隆的仓库 分支管理创建与合并分支 1234567891011121314$ git checkout -b &lt;branch name&gt;创建并且切换到该 分支上$ git branch 查看当前分支情况，*对应的是当前所在的分支$ git checkout master切回到主分支$ git merge &lt;branch name&gt;将该分支合并到主分支上$ git branch -d &lt;branch name&gt;删除该分支 解决冲突 123当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log --graph命令可以看到分支合并图。 分支管理策略 1合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支 123修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 Feature分支 12开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作 (由于没有多人协作的项目经验，这一块看的并不是很明白，只能先把小结部分的内容接下来，以后有类似经验了再消化吸收) 123456查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 Rebase 12$git rebase（这个操作也是没有实践不大好理解啊，就先放这儿） 标签管理创建标签 123命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；命令git tag可以查看所有标签。 操作标签 1234命令git push origin &lt;tagname&gt;可以推送一个本地标签；命令git push origin --tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tagname&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。删除远程标签时，需要先删除本地标签。 配置别名这个看完了感觉还是很实用的，可以把一些比较长的命令行给简化拼写。我这刚刚入门，也不知道这么配置完了之后如果有问题，如何再修改回原来的配置，所以就先用着默认指令吧，以后再来修改。 windows下一些命令行操作12345ls dir 当前目录下的文件pwd chdir 显示当前所在的路径cat type &lt;file&gt; 显示文件内容rm del &lt;file&gt; 删除文件cd .. 返回上一级目录]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二暑假总结]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结一下大二暑假做的事儿，展望一下新学期 谈谈这个暑假放假的时间总是这么的快，感觉没做什么事情，假期又已经结束了。这个暑假不同于以前，自己决定在学校待一段时间，多学点东西再回家。虽然可能学的也不是很多，但至少还是有在学习的。所以想总结一下自己都在这个暑假干了些什么吧。 前期（托福课之前） 这段时间的话主要就是在做爬虫项目，学习了如何使用scrapy框架来进行爬虫。首先是通过豆瓣top250来进行练手，然后爬取了两个学术网站。爬取完后将数据存储到mysql数据库中。完成度的话，还有一些不足，比如mysql知识用navicat进行管理，并没有对数据库有更深的学习。而数据库这个方面在其他学习过程中发现应该是计算机知识很重要的一方面，大三还要多加学习。 还做的一些事就是在洛谷上刷题，学习计网，然后当时每天都有花时间背单词。平时锻炼也很多，晚上不是去打篮球就是去健身。这段时间过得还是挺满意的。 中期（托福课阶段） 这期间主要做的就两个事儿吧，1. 上托福课，2. 学习Java 托福课上完了，口语和听力的收获挺大，阅读的话主要还是靠自己来刷，写作其实当时老师讲的我觉得并没有特别清楚吧，这个后面练习的时候再去网上看看总结什么的。 Java主要是跟着菜鸟教程来学的。当时学到了Java包，基本上只是掌握了Java基础语法，后面的一些高级特性还没有深入学习。练习主要是靠LeetCode来刷题练习，算是练Java的使用，以及提高算法能力。Java的话大三上前段时间加紧学习，然后跟进羊哥推荐的开源项目的学习。 这段时间作息开始不是很规律，早上不早起，晚上早睡了睡不着，学习效率并没有很高。 后期（在家) 学习项目做了的就是刷tpo的阅读，做了有个3篇，得分都在21左右，阅读需要提高的地方还有很多。然后就是在leetcode上面刷题了，在探索中找到了“初级算法”，过一下里面的题目，提高一下自己的算法能力。 这一篇博客距离上一篇差不多有一个月了。前中期的学习还经常写一写博客来记录，后期在家就懒了不少，每天学习也不是很多吧。开学了就要开始继续努力，坚持写博客了。 展望一下大三开学了，加权单也贴到了墙上，看着大二的成绩，自己还是挺不满意的吧。跟大一比，退步了50名左右，真的就是在保研的边缘摇晃了。回想大二，感觉自己真的是很懈怠，课程内任务没有好好学，课程外也没有去学一些自己感兴趣的东西到现在了还啥都不会，就不具备一个开发者的思维模式以及能力。 这个暑假看了不少其他优秀的人是如何学习的，以及如何转变自己学习的思维模式，感觉还是受益良多的。仔细看了看大三的课程，课程相比大一大二，反而感觉课程少了不少，但都是专业课，所以要更加用心去学习，去实践。空余的很多时间要多拿来跑一下开源项目，提升一下自己的能力。 九月份任务 TPO刷题，每天2-3h的英语学习时间（不包括背单词的时间，单词每天也要背起来） 9.15号CSP考试，前两周就多花点时间在这个上面，一二题争取用时短，然后全对。第三题可能真的没法儿看懂，看不懂就算了，反正三四题争取一下。 学习一下git，以后也要用到的。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:数组题(1)]]></title>
    <url>%2F2019%2F08%2F01%2FLeetCode-%E6%95%B0%E7%BB%84%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录 26. 删除排序数组中的重复项题目描述(简单)给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 解题思路开始对原地修改有一些疑问, 后来发现直接进行覆盖即可, 就没什么难度了. 注意数组长度为0这种情况. 解题代码12345678910111213class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0) return 0; int i = 0; for(int j=1; j&lt;nums.length; j++)&#123; if(nums[j]!= nums[i])&#123; i ++; nums[i] = nums[j]; &#125; &#125; return (i+1); &#125;&#125; 27. 移除元素题目描述(简单)给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element 解题思路 排序 双指针 先对数组进行排序, 然后通过双指针找到等于val的第一个数, 和不等于val的第一个数, 然后进行覆盖 解题代码123456789101112131415161718192021class Solution &#123; public int removeElement(int[] nums, int val) &#123; if(nums.length == 0) return 0; Arrays.sort(nums); int front,tail; for(front=0; front&lt;nums.length; front++) &#123; if(nums[front] == val) break; &#125; for(tail = front; tail&lt;nums.length; tail++) &#123; if(nums[tail] != val) break; &#125; if(tail == nums.length) return front; else &#123; for(; tail&lt;nums.length; tail++) &#123; nums[front] = nums[tail]; front++; &#125; &#125; return front; &#125;&#125; 283. 移动零题目描述(简单)给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes 解题思路先把非0的数挪到前面, 并记录0的个数. 挪完后把后面的数全部置0即可 解题代码1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int front= 0; int counter = 0; //int [] nums = &#123;0,1,0,3,12&#125;; for(int i=0 ; i&lt;nums.length; i++) &#123; if(nums[i] != 0) &#123; nums[front] = nums[i]; front ++; &#125; else counter++; &#125; for(int i=front; i&lt;nums.length; i++) &#123; nums[i] = 0; &#125; &#125;&#125; 总结前三题刚上手LeetCode, 大部分题目对目前的我有点难度, 所以就从自己比较熟悉的数组开始尝试, 边学习Java的使用, 边提高算法能力. 前三题其实还是挺简单的, 主要是一个原地修改数组不另外开辟空间的要求, 最后用覆盖的方法解决了就好了. 11. 盛最多水的容器题目描述(中等)给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water 解题思路解法一 这个解法可以说相当好像到,就是暴力穷举, 用一个双重循环, 将所有的情况都枚举出来, 取其中的最大值即可. 想是很好想, 但是这个算法的效率却很低, 时间复杂度为O(n^2), 所以在这个题中, 我考虑的就是如何用别的算法来达到降低时间的这个目的. 我先用双重循环试了试它的时间, 最后结果为Java提交记录中的30%, 可见效率之低. 解法二 双指针解法:我是没想出来这个解法, 也是看了官方题解才明白的. 它的思路在于两条线段之间形成的区域面积受制于两条边中较短的边. 其次, 两条边距离越远, 面积越大. 通过放置两个指针, 一头一尾, 记录当前最大面积max. 然后移动较短的指针, 更新最大面积max, 直至头尾指针相遇. 只需要扫描一遍即可找到最大值, 所以时间复杂度为O(n). 这个方法看起来比较简单, 但是我在思考为什么这个算法正确的时候花了不少时间. 也看了很多讨论, 利用数学的论证这个方法的正确性, 最终也算是搞懂了. 思考 我发现对于一个问题啊, 我们特别喜欢用暴力穷举的方法来的到答案, 因为在你穷举的过程中看似吧每种可能都给考虑到了,是最周全的方法,结果也是最可靠的. 但是这种方法就会消耗更多的时间, 并且在问题规模大到一定程度后, 穷举在一定的时间内就是不可能完成的, 所以才会有算法的出现. 个人观点, 算法就是用一定的方法, 避免那些”不必要的”穷举, 只需要对部分内容进行操作, 就可以得到正确的结果的过程. 当然算法并不是说一拍脑子就想出来的, 可能想一个算法的过程会有aha moment, 但是想出来了之后都是要通过数学的证明来确定他的正确性的. 所以说数学这个工具也还是很重要的呢. 解题代码1234567891011public static int maxAreaBetter(int[] height) &#123; int max=0; for(int i=0, j=height.length-1; i&lt;j;) &#123; max = Math.max(max, Math.min(height[i], height[j])*(j-i)); if(height[i] &lt; height[j]) &#123; i++; &#125; else j--; &#125; return max; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark实验：HTTP]]></title>
    <url>%2F2019%2F07%2F21%2FWireshark%E5%AE%9E%E9%AA%8C%EF%BC%9AHTTP%2F</url>
    <content type="text"><![CDATA[掌握HTTP相关，实验内容比较简单，尝试学习中成长。 1.基本HTTP GET/response交互这个实验的本身很简单，就是让你访问一个仅含有一段简单的html代码的网站，然后根据http协议的请求头所包含的信息，来回答问题即可。但是在这个过程中我还遇到了挺多奇奇怪怪的问题。最开始操作不熟练，每次筛选后的到的纪录依然很多，多次尝试后，终于得到了和任务书介绍的类似界面。但是我发现自己的HTTP状态响应为304 Not Modified, 和任务书中的200 OK不同，就很奇怪为什么。当时在下面详情里面看到了If Modified Since, 以及Accept Language。因为不是很明白为什么会出现这种情况，于是就先跳过实验一，看实验二去了。看了实验二才知道，304响应是因为我之前就访问过这个界面，然后浏览器产生了这个网页的缓存，304是说这个界面没有改变的意思。 2.HTTP条件Get/response交互实验二中熟悉操作之后就得到了对应的结果。在检查If-Modified-Since时，发现状态304中出现了这个标识，而且在状态200中，对应的是Last Modified,而且二者时间是一致的。探究If-Modified-Since是何物，网上给到的结果是 意思是我们在请求时会发送给服务器上次它修改这个文件最后一次时间，如果服务器发现仍然没有修改这个文件，就会返回304文件为改变的信息，调用本地caceh缓存，如果改变就会重新得到。 3.检索长文件实验三顺利执行，结果如下图数据信息包含在HTTP响应体里面。由于html文本过长，所以TCP共分了4个帧来存放这些信息，分组情况如下图 4.具有嵌入对象的HTML文档实验四捕获结果如下一共有三个HTTP GET请求，访问的IP地址都是128.119.245.12，按顺序得到了三个内容，分别是：html文件、pearson的图片、以及教材第五版的封面图，由于请求的时间不同，所以判断应该不是并行获得，而是按顺序请求获得。 5.HTTP认证实验五结果如下图最开始登录之后得到的界面是404 Not Found，感觉很奇怪啊，这不应该啊。后来检查了一下仓库中的URL，发现是给的URL打漏了一个”-“，打开正确的URL即可得到正确的结果界面。然后就在issue里面提交了这个问题，觉得Github还是很有意思啊。任务中让我们尝试base64加密方式，在wireshark中会自动解码出来，具体结果如下所示 Authorization: Basic d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=\r\n Credentials: wireshark-students:network上面是加密前，下面是解密后的结果。可见我们的密码并不是很安全，需要别的措施来防止别人窃取。 6.实验收获这个实验还是蛮简单的，具体步骤不知道怎么做或者是不知道要得到什么结果，参照一下Github上的pdf也就很容易解决。相比较第一个Wireshark，这个更加有实际操作的感觉，也锻炼了使用这个工具，继续努力~]]></content>
      <categories>
        <category>实操纪录</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codesheep笔记:为什么推荐Java而不是C++]]></title>
    <url>%2F2019%2F07%2F19%2Fcodesheep%E7%AC%94%E8%AE%B0-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90java%E8%80%8C%E4%B8%8D%E6%98%AFc%2F</url>
    <content type="text"><![CDATA[java学过很多次，但是每次都没有坚持学下去，觉得没有什么动力，看了羊哥的这个视频，觉得更有必要好好学习Java了。 1.目前的市场情况 互联网服务背后主流驱动技术就是Java，应用广泛 招聘岗位远比其他语言大的多 羊哥的实际感受：C/C++项目经历没有什么连续性，而Java则不一样。虽然业务不同，但编程经验都是一样的，具有较强的连续性。而且随着经验的丰富，可以转换到高级的方向很多 总结：市场表现来看，Java是最好的语言 2.内因：Java本身也很争气Java自身强大与优雅之处： 面向对象。Java是一个纯面向对象的语言，本身就是面向企业开发、大系统来设计的 静态语言。静态语言就有编译过程，在编译过程中可以报错，确保系统安全；其次，静态语言的速度会比动态语言快很多 Java两个最强的技术特性： 跨平台特性。 自动内存管理。 3.Java语言的应用场景和生态J2EE生态丰富完整，拥有很多可靠的开源软件 4.Java新的生命力的注入版本更新迭代快，更多高性能属性不断加入 5.怎么学 Java的基础语法 企业级开发框架：SSM、Spring Boot。数据库学习 书籍推荐]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>codesheep笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络（自顶向下方法）》学习笔记（持续更新）]]></title>
    <url>%2F2019%2F07%2F18%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面暑期实习做网络爬虫相关的事情，对计网有了一定的初步认识，感觉蛮有趣的，想到下学期也要学习计网，所以就准备提前学习了。买了课本，也在MOOC上学习，用博客来记录学习笔记。 实验资料：wireshark实验 1. 计算机网络和因特网1.1 什么是因特网网络：许多计算机连接在一起。 互联网（internet）：许多网络连接在一起。 因特网（Internet）：全球最大的互联网。 ISP（Internet Service Provider）：网络运营商（如移动，联通，电信等）。 端系统、分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接受和发送。TCP(Transmission Control Protocol, 传输控制协议)和IP(Internet Protocol, 网际协议)是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接受的分组格式。因特网的主要协议统称TCP/IP协议。 套接字接口（socket interface）:由与因特网相连的端系统提供，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序员交付数据的方式。因特网套接字接口是一套发送程序必须遵循的规则集合。可以与寄信、送信、收信的流程来类比。 协议：定义了在两个或多个通信实体之间交换的报文和顺序。以及报文发送和/或接受一条报文或其他事件所采取的动作。类比人类之间的交谈。 1.2 网络边缘端系统：与因特网相连的计算机和其他设备的称呼，因为位于因特网的边缘而得名。组成：包括了桌面计算机、服务器和移动计算机。端系统也统称为主机。 以太网（Ethernet）是一种计算机局域网技术，是目前应用最普遍的局域网技术。 1.3 网络核心为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。（交换机主要有两类：路由器和链路层交换机）。多数分组交换机在链路的输入端使用存储转发传输机制。 输出缓存（也称输出队列）：用于存储路由器准备发往那条链路的分组。排队时延：到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。分组丢失（丢包）：一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满，到达的分组或已经排队的分组之一将被丢弃。 1.4 分组交换网中的时延、丢包和吞吐量2. 应用层2.1 应用层协议原理2.2 Web和HTTP2.3 因特网中的电子邮件2.4 DNS:因特网的目录服务2.4.1 DNS提供的服务识别主机有两种方式，通过主机名或者IP地址，需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统DNS（Domain Name System）的主要任务。DNS是： 一个由分层的DNS服务器实现的分布式数据库。 一个使得主机能够查询分布式数据库的应用层协议。提供的其他重要服务： 主机别名。存在别名时，原始名被称为规范主机名。 邮件服务器别名。 负载分配。 2.4.2 工作机理工作过程应用程序需要主机名转换成IP地址 → 调用DNS客户算 → 用户主机上的DNS收到请求后，向网络中发送一个DNS查询报文（请求、回答报文使用UDP数据包经端口53发送） → 收到一个提供所希望映射的DNS回答报文 → 映射结果被传递到调用DNS的应用程序。 最开始的DNS的简单设计是一个DNS服务器，集中式设计存在如下问题：单点故障、通信容量、远距离的集中式数据库、维护。因此DNS采用了分布式的设计方案。 分布式、层次数据库大致讲，共有3种类型的DNS服务器： 根DNS服务器。提供TLD服务器的IP地址。 顶级域（Top-Level Domain, TLD）(DNS)服务器。顶级域（com, org, net, edu, gov）和所有国家的顶级域(uk, fr, ca, jp)都有TLD服务器。提供全为DNS服务器的IP地址。 权威DNS服务器。层次之外还有一种重要的DNS服务器：本地DNS服务器。每个ISP都有一台本地DNS服务器。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。查询方式：理论上讲，查询可以是递归查询也可以是迭代查询。实践中采取如下模式：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。 DNS缓存目的：为了改善时延性能并减少在因特网上到处传输的DNS报文数量。原理：在一个请求链中，当某DNS服务器接收到一个DNS回答时，它能够将映射缓存在本地储存器中。如果在DNS服务器中缓存了一台主机名/IP地址对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址，即使它不是该主机的权威服务器。缓存的信息通常保留两天。 2.4.3 记录和报文pass P2P文件分发套接字编程：生成网络应用本节目的：考察研发一个CS服务器应用程序中的关键问题，将实现一个非常简单的CS服务器应用程序代码 .1 UDP套接字 术语缩写]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七月上半月总结]]></title>
    <url>%2F2019%2F07%2F18%2F%E4%B8%83%E6%9C%88%E4%B8%8A%E5%8D%8A%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[暑假过的时间是真的快啊,感觉还没做些什么七月就已经过半了，想着还是有必要纪录一下这段时间都干了些什么，也算一种成长记录与自我总结反思。 七月上半月我都做了些什么： 暑期实习 学习了scapry框架下爬虫的使用 对论文期刊进行了爬虫实践，将论文信息按照学长给的表格给爬取了下来。 将论文内容存储到mysql数据库。 英语学习 每日背单词 进行了几天的听力训练 计算机网络学习 跟着中国大学mooc上的课程学习。 看《计算机网络（自顶向下方法）》 每日运动 基本上每天都会去健身房或者去球场打球，如果不是很想去，也会在寝室进行一些健身运动。 不足之处： 说好的每天规律作息，其实并没有很好地去完成。每天晚上不是很睡得着，白天就起不来，经常睡到九十点，一个上午就浪费掉了。 爬虫项目目前进度挺慢的，不是很上心。 计网的学习又是受会出现三天打鱼两天晒网的情况，不是很好。 有一段时间没有去洛谷和CSP打代码咯。 评价一下自己上半个月，我觉得基本满意，还有不足需要继续努力。通过做爬虫的实习，开始对计网感兴趣，并自主去学习，我觉得还是很有意思的。健身运动也没停，body building做的还不错，希望能更壮一点。下半个月要开始上托福课了，作息应该会比较规律，要继续努力，越努力越优秀。 下个月要做的事： 抓紧实习项目的进展，不懂得多自我学习解决，实在不会再去麻烦学长。 认真上托福课，不能让钱白花，多自学。 英语背单词不要中断，养成一种习惯。 培养写博客的习惯。搭建自己的博客不是目的，写博客才是最终的需要去做的，坚持学习，坚持输出。 抽时间去oj做做题鸭。 健身再壮一点。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客——hexo搭建以及美化]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面因为刚好想总结一下这段时间的学习到的东西，正在考虑注册个csdn还是简书，看到了羊哥的视频，就心血来潮自己搭了个独立博客，还是很有趣的，希望以后能多多学习多多积累。 搭建过程首先是根据羊哥评论里面一个小伙伴博客的帖子，把前期安装给解决了。然后跟着羊哥（codesheep）的视频把博客部署到了github上去。最后看知乎的一个帖子来美化我的博客。怎么说呢，现在markdown格式什么的也是第一次接触，都挺不熟练的，但是总要迈出第一步的嘛。这一篇就记录一下搭建的过程，有些东西还想补充，但是markdown语法不会，不知道该怎么添加，就以后再加。这几天就把这段时间爬虫的学习经历总结一下，发一篇博客。 图床搭建博客中的图片插入还会一个问题，需要使用到图床，这里采用的是七牛云图床，具体搭建方法参考了这个博客。 刚才还发现markdown格式自己疏忽的地方，在添加“博客”这个链接的时候，通过中括号+小括号，发现并没有像之前的链接会变成蓝色，检查之后，原来是使用了中文括号的缘故。这种问题在编译器里面看都不是很容易察觉，更不用说在这个markdownpad中了，还是要注意一下。 博客发表之前每次发布、修改，都要通过下面三个指令来实现： hexo clean hexo g hexo d之前感觉每次都这么输挺麻烦的，不过好像发布就得这个样子，后期再研究研究。发布之前可以先通过本地的localhost来看一下博客格式是否与自己想法一致，通过输入下面的指令来开启本地hexo服务。 hexo s不过这种方式默认使用的是4000端口，我的本地4000端口好像被占用了，解决这个有两种方法，一个是干掉本地占用4000端口的服务，让hexo来使用。另一种方式就是将hexo服务换一个端口来实现，这里我使用的是5000端口，指令如下。 hexo s -p 5000美化进阶之前就是换了个Next主题，虽然说挺够用的，还是挺简陋的，不够酷，所以找了个教程来配置next主题，先码住，之后再修改。Hexo博客第三方主题next进阶教程一个next基础配置帖子,很受用。 博客再更我突然明白了为什么有现成的博客网站大家不用，而是选择自己搭建博客这种比较麻烦的方式，因为可以自定义。有的人喜欢现成的东西，用起来简单省心，虽然可能有一些自己想有但是没有的功能，或者是用起来不舒服的地方。有的人喜欢自己来定义，虽然比较麻烦，比较操心，但出了什么问题都可以通过自己来解决，就很合自己的心意。就像《食戟之灵》里面的central和幸平他们的争斗，也是如此，为了自由而战。也明白了为什么UDP协议既然是不安全的，都用TCP协议不就好了，因为UDP轻量，方便自己去定制。 markdown的一些语法markdown让文字居中和带颜色]]></content>
  </entry>
</search>
