<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode:数组题(1)]]></title>
    <url>%2F2019%2F08%2F01%2FLeetCode-%E6%95%B0%E7%BB%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录 26. 删除排序数组中的重复项题目描述(简单)给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 解题思路开始对原地修改有一些疑问, 后来发现直接进行覆盖即可, 就没什么难度了. 注意数组长度为0这种情况. 解题代码12345678910111213class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0) return 0; int i = 0; for(int j=1; j&lt;nums.length; j++)&#123; if(nums[j]!= nums[i])&#123; i ++; nums[i] = nums[j]; &#125; &#125; return (i+1); &#125;&#125; 27. 移除元素(简单)题目描述(简单)给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element 解题思路 排序 双指针 先对数组进行排序, 然后通过双指针找到等于val的第一个数, 和不等于val的第一个数, 然后进行覆盖 解题代码123456789101112131415161718192021class Solution &#123; public int removeElement(int[] nums, int val) &#123; if(nums.length == 0) return 0; Arrays.sort(nums); int front,tail; for(front=0; front&lt;nums.length; front++) &#123; if(nums[front] == val) break; &#125; for(tail = front; tail&lt;nums.length; tail++) &#123; if(nums[tail] != val) break; &#125; if(tail == nums.length) return front; else &#123; for(; tail&lt;nums.length; tail++) &#123; nums[front] = nums[tail]; front++; &#125; &#125; return front; &#125;&#125; 283. 移动零题目描述(简单)给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes 解题思路先把非0的数挪到前面, 并记录0的个数. 挪完后把后面的数全部置0即可 解题代码1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int front= 0; int counter = 0; //int [] nums = &#123;0,1,0,3,12&#125;; for(int i=0 ; i&lt;nums.length; i++) &#123; if(nums[i] != 0) &#123; nums[front] = nums[i]; front ++; &#125; else counter++; &#125; for(int i=front; i&lt;nums.length; i++) &#123; nums[i] = 0; &#125; &#125;&#125; 总结前三题刚上手LeetCode, 大部分题目对目前的我有点难度, 所以就从自己比较熟悉的数组开始尝试, 边学习Java的使用, 边提高算法能力. 前三题其实还是挺简单的, 主要是一个原地修改数组不另外开辟空间的要求, 最后用覆盖的方法解决了就好了. 11. 盛最多水的容器题目描述(中等)给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water 解题思路解法一 这个解法可以说相当好像到,就是暴力穷举, 用一个双重循环, 将所有的情况都枚举出来, 取其中的最大值即可. 想是很好想, 但是这个算法的效率却很低, 时间复杂度为O(n^2), 所以在这个题中, 我考虑的就是如何用别的算法来达到降低时间的这个目的. 我先用双重循环试了试它的时间, 最后结果为Java提交记录中的30%, 可见效率之低. 解法二 双指针解法:我是没想出来这个解法, 也是看了官方题解才明白的. 它的思路在于两条线段之间形成的区域面积受制于两条边中较短的边. 其次, 两条边距离越远, 面积越大. 通过放置两个指针, 一头一尾, 记录当前最大面积max. 然后移动较短的指针, 更新最大面积max, 直至头尾指针相遇. 只需要扫描一遍即可找到最大值, 所以时间复杂度为O(n). 这个方法看起来比较简单, 但是我在思考为什么这个算法正确的时候花了不少时间. 也看了很多讨论, 利用数学的论证这个方法的正确性, 最终也算是搞懂了. 思考 我发现对于一个问题啊, 我们特别喜欢用暴力穷举的方法来的到答案, 因为在你穷举的过程中看似吧每种可能都给考虑到了,是最周全的方法,结果也是最可靠的. 但是这种方法就会消耗更多的时间, 并且在问题规模大到一定程度后, 穷举在一定的时间内就是不可能完成的, 所以才会有算法的出现. 个人观点, 算法就是用一定的方法, 避免那些”不必要的”穷举, 只需要对部分内容进行操作, 就可以得到正确的结果的过程. 当然算法并不是说一拍脑子就想出来的, 可能想一个算法的过程会有aha moment, 但是想出来了之后都是要通过数学的证明来确定他的正确性的. 所以说数学这个工具也还是很重要的呢. 解题代码1234567891011public static int maxAreaBetter(int[] height) &#123; int max=0; for(int i=0, j=height.length-1; i&lt;j;) &#123; max = Math.max(max, Math.min(height[i], height[j])*(j-i)); if(height[i] &lt; height[j]) &#123; i++; &#125; else j--; &#125; return max; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark实验：HTTP]]></title>
    <url>%2F2019%2F07%2F21%2FWireshark%E5%AE%9E%E9%AA%8C%EF%BC%9AHTTP%2F</url>
    <content type="text"><![CDATA[掌握HTTP相关，实验内容比较简单，尝试学习中成长。 1.基本HTTP GET/response交互这个实验的本身很简单，就是让你访问一个仅含有一段简单的html代码的网站，然后根据http协议的请求头所包含的信息，来回答问题即可。但是在这个过程中我还遇到了挺多奇奇怪怪的问题。最开始操作不熟练，每次筛选后的到的纪录依然很多，多次尝试后，终于得到了和任务书介绍的类似界面。但是我发现自己的HTTP状态响应为304 Not Modified, 和任务书中的200 OK不同，就很奇怪为什么。当时在下面详情里面看到了If Modified Since, 以及Accept Language。因为不是很明白为什么会出现这种情况，于是就先跳过实验一，看实验二去了。看了实验二才知道，304响应是因为我之前就访问过这个界面，然后浏览器产生了这个网页的缓存，304是说这个界面没有改变的意思。 2.HTTP条件Get/response交互实验二中熟悉操作之后就得到了对应的结果。在检查If-Modified-Since时，发现状态304中出现了这个标识，而且在状态200中，对应的是Last Modified,而且二者时间是一致的。探究If-Modified-Since是何物，网上给到的结果是 意思是我们在请求时会发送给服务器上次它修改这个文件最后一次时间，如果服务器发现仍然没有修改这个文件，就会返回304文件为改变的信息，调用本地caceh缓存，如果改变就会重新得到。 3.检索长文件实验三顺利执行，结果如下图数据信息包含在HTTP响应体里面。由于html文本过长，所以TCP共分了4个帧来存放这些信息，分组情况如下图 4.具有嵌入对象的HTML文档实验四捕获结果如下一共有三个HTTP GET请求，访问的IP地址都是128.119.245.12，按顺序得到了三个内容，分别是：html文件、pearson的图片、以及教材第五版的封面图，由于请求的时间不同，所以判断应该不是并行获得，而是按顺序请求获得。 5.HTTP认证实验五结果如下图最开始登录之后得到的界面是404 Not Found，感觉很奇怪啊，这不应该啊。后来检查了一下仓库中的URL，发现是给的URL打漏了一个”-“，打开正确的URL即可得到正确的结果界面。然后就在issue里面提交了这个问题，觉得Github还是很有意思啊。任务中让我们尝试base64加密方式，在wireshark中会自动解码出来，具体结果如下所示 Authorization: Basic d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=\r\n Credentials: wireshark-students:network上面是加密前，下面是解密后的结果。可见我们的密码并不是很安全，需要别的措施来防止别人窃取。 6.实验收获这个实验还是蛮简单的，具体步骤不知道怎么做或者是不知道要得到什么结果，参照一下Github上的pdf也就很容易解决。相比较第一个Wireshark，这个更加有实际操作的感觉，也锻炼了使用这个工具，继续努力~]]></content>
      <categories>
        <category>实操纪录</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codesheep笔记:为什么推荐Java而不是C++]]></title>
    <url>%2F2019%2F07%2F19%2Fcodesheep%E7%AC%94%E8%AE%B0-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90java%E8%80%8C%E4%B8%8D%E6%98%AFc%2F</url>
    <content type="text"><![CDATA[java学过很多次，但是每次都没有坚持学下去，觉得没有什么动力，看了羊哥的这个视频，觉得更有必要好好学习Java了。 1.目前的市场情况 互联网服务背后主流驱动技术就是Java，应用广泛 招聘岗位远比其他语言大的多 羊哥的实际感受：C/C++项目经历没有什么连续性，而Java则不一样。虽然业务不同，但编程经验都是一样的，具有较强的连续性。而且随着经验的丰富，可以转换到高级的方向很多 总结：市场表现来看，Java是最好的语言 2.内因：Java本身也很争气Java自身强大与优雅之处： 面向对象。Java是一个纯面向对象的语言，本身就是面向企业开发、大系统来设计的 静态语言。静态语言就有编译过程，在编译过程中可以报错，确保系统安全；其次，静态语言的速度会比动态语言快很多 Java两个最强的技术特性： 跨平台特性。 自动内存管理。 3.Java语言的应用场景和生态J2EE生态丰富完整，拥有很多可靠的开源软件 4.Java新的生命力的注入版本更新迭代快，更多高性能属性不断加入 5.怎么学 Java的基础语法 企业级开发框架：SSM、Spring Boot。数据库学习 书籍推荐]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>codesheep笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络（自顶向下方法）》学习笔记（持续更新）]]></title>
    <url>%2F2019%2F07%2F18%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面暑期实习做网络爬虫相关的事情，对计网有了一定的初步认识，感觉蛮有趣的，想到下学期也要学习计网，所以就准备提前学习了。买了课本，也在MOOC上学习，用博客来记录学习笔记。 实验资料：wireshark实验 1. 计算机网络和因特网1.1 什么是因特网网络：许多计算机连接在一起。 互联网（internet）：许多网络连接在一起。 因特网（Internet）：全球最大的互联网。 ISP（Internet Service Provider）：网络运营商（如移动，联通，电信等）。 端系统、分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接受和发送。TCP(Transmission Control Protocol, 传输控制协议)和IP(Internet Protocol, 网际协议)是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接受的分组格式。因特网的主要协议统称TCP/IP协议。 套接字接口（socket interface）:由与因特网相连的端系统提供，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序员交付数据的方式。因特网套接字接口是一套发送程序必须遵循的规则集合。可以与寄信、送信、收信的流程来类比。 协议：定义了在两个或多个通信实体之间交换的报文和顺序。以及报文发送和/或接受一条报文或其他事件所采取的动作。类比人类之间的交谈。 1.2 网络边缘端系统：与因特网相连的计算机和其他设备的称呼，因为位于因特网的边缘而得名。组成：包括了桌面计算机、服务器和移动计算机。端系统也统称为主机。 以太网（Ethernet）是一种计算机局域网技术，是目前应用最普遍的局域网技术。 1.3 网络核心为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。（交换机主要有两类：路由器和链路层交换机）。多数分组交换机在链路的输入端使用存储转发传输机制。 输出缓存（也称输出队列）：用于存储路由器准备发往那条链路的分组。排队时延：到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。分组丢失（丢包）：一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满，到达的分组或已经排队的分组之一将被丢弃。 1.4 分组交换网中的时延、丢包和吞吐量2. 应用层2.1 应用层协议原理2.2 Web和HTTP2.3 因特网中的电子邮件2.4 DNS:因特网的目录服务2.4.1 DNS提供的服务识别主机有两种方式，通过主机名或者IP地址，需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统DNS（Domain Name System）的主要任务。DNS是： 一个由分层的DNS服务器实现的分布式数据库。 一个使得主机能够查询分布式数据库的应用层协议。提供的其他重要服务： 主机别名。存在别名时，原始名被称为规范主机名。 邮件服务器别名。 负载分配。 2.4.2 工作机理工作过程应用程序需要主机名转换成IP地址 → 调用DNS客户算 → 用户主机上的DNS收到请求后，向网络中发送一个DNS查询报文（请求、回答报文使用UDP数据包经端口53发送） → 收到一个提供所希望映射的DNS回答报文 → 映射结果被传递到调用DNS的应用程序。 最开始的DNS的简单设计是一个DNS服务器，集中式设计存在如下问题：单点故障、通信容量、远距离的集中式数据库、维护。因此DNS采用了分布式的设计方案。 分布式、层次数据库大致讲，共有3种类型的DNS服务器： 根DNS服务器。提供TLD服务器的IP地址。 顶级域（Top-Level Domain, TLD）(DNS)服务器。顶级域（com, org, net, edu, gov）和所有国家的顶级域(uk, fr, ca, jp)都有TLD服务器。提供全为DNS服务器的IP地址。 权威DNS服务器。层次之外还有一种重要的DNS服务器：本地DNS服务器。每个ISP都有一台本地DNS服务器。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。查询方式：理论上讲，查询可以是递归查询也可以是迭代查询。实践中采取如下模式：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。 DNS缓存目的：为了改善时延性能并减少在因特网上到处传输的DNS报文数量。原理：在一个请求链中，当某DNS服务器接收到一个DNS回答时，它能够将映射缓存在本地储存器中。如果在DNS服务器中缓存了一台主机名/IP地址对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址，即使它不是该主机的权威服务器。缓存的信息通常保留两天。 2.4.3 记录和报文pass P2P文件分发套接字编程：生成网络应用本节目的：考察研发一个CS服务器应用程序中的关键问题，将实现一个非常简单的CS服务器应用程序代码 .1 UDP套接字 术语缩写]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七月上半月总结]]></title>
    <url>%2F2019%2F07%2F18%2F%E4%B8%83%E6%9C%88%E4%B8%8A%E5%8D%8A%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[暑假过的时间是真的快啊,感觉还没做些什么七月就已经过半了，想着还是有必要纪录一下这段时间都干了些什么，也算一种成长记录与自我总结反思。 七月上半月我都做了些什么： 暑期实习 学习了scapry框架下爬虫的使用 对论文期刊进行了爬虫实践，将论文信息按照学长给的表格给爬取了下来。 将论文内容存储到mysql数据库。 英语学习 每日背单词 进行了几天的听力训练 计算机网络学习 跟着中国大学mooc上的课程学习。 看《计算机网络（自顶向下方法）》 每日运动 基本上每天都会去健身房或者去球场打球，如果不是很想去，也会在寝室进行一些健身运动。 不足之处： 说好的每天规律作息，其实并没有很好地去完成。每天晚上不是很睡得着，白天就起不来，经常睡到九十点，一个上午就浪费掉了。 爬虫项目目前进度挺慢的，不是很上心。 计网的学习又是受会出现三天打鱼两天晒网的情况，不是很好。 有一段时间没有去洛谷和CSP打代码咯。 评价一下自己上半个月，我觉得基本满意，还有不足需要继续努力。通过做爬虫的实习，开始对计网感兴趣，并自主去学习，我觉得还是很有意思的。健身运动也没停，body building做的还不错，希望能更壮一点。下半个月要开始上托福课了，作息应该会比较规律，要继续努力，越努力越优秀。 下个月要做的事： 抓紧实习项目的进展，不懂得多自我学习解决，实在不会再去麻烦学长。 认真上托福课，不能让钱白花，多自学。 英语背单词不要中断，养成一种习惯。 培养写博客的习惯。搭建自己的博客不是目的，写博客才是最终的需要去做的，坚持学习，坚持输出。 抽时间去oj做做题鸭。 健身再壮一点。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客——hexo搭建以及美化]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面因为刚好想总结一下这段时间的学习到的东西，正在考虑注册个csdn还是简书，看到了羊哥的视频，就心血来潮自己搭了个独立博客，还是很有趣的，希望以后能多多学习多多积累。 搭建过程首先是根据羊哥评论里面一个小伙伴博客的帖子，把前期安装给解决了。然后跟着羊哥（codesheep）的视频把博客部署到了github上去。最后看知乎的一个帖子来美化我的博客。怎么说呢，现在markdown格式什么的也是第一次接触，都挺不熟练的，但是总要迈出第一步的嘛。这一篇就记录一下搭建的过程，有些东西还想补充，但是markdown语法不会，不知道该怎么添加，就以后再加。这几天就把这段时间爬虫的学习经历总结一下，发一篇博客。 图床搭建博客中的图片插入还会一个问题，需要使用到图床，这里采用的是七牛云图床，具体搭建方法参考了这个博客。 刚才还发现markdown格式自己疏忽的地方，在添加“博客”这个链接的时候，通过中括号+小括号，发现并没有像之前的链接会变成蓝色，检查之后，原来是使用了中文括号的缘故。这种问题在编译器里面看都不是很容易察觉，更不用说在这个markdownpad中了，还是要注意一下。 博客发表之前每次发布、修改，都要通过下面三个指令来实现： hexo clean hexo g hexo d之前感觉每次都这么输挺麻烦的，不过好像发布就得这个样子，后期再研究研究。发布之前可以先通过本地的localhost来看一下博客格式是否与自己想法一致，通过输入下面的指令来开启本地hexo服务。 hexo s不过这种方式默认使用的是4000端口，我的本地4000端口好像被占用了，解决这个有两种方法，一个是干掉本地占用4000端口的服务，让hexo来使用。另一种方式就是将hexo服务换一个端口来实现，这里我使用的是5000端口，指令如下。 hexo s -p 5000美化进阶之前就是换了个Next主题，虽然说挺够用的，还是挺简陋的，不够酷，所以找了个教程来配置next主题，先码住，之后再修改。Hexo博客第三方主题next进阶教程一个next基础配置帖子,很受用。 博客再更我突然明白了为什么有现成的博客网站大家不用，而是选择自己搭建博客这种比较麻烦的方式，因为可以自定义。有的人喜欢现成的东西，用起来简单省心，虽然可能有一些自己想有但是没有的功能，或者是用起来不舒服的地方。有的人喜欢自己来定义，虽然比较麻烦，比较操心，但出了什么问题都可以通过自己来解决，就很合自己的心意。就像《食戟之灵》里面的central和幸平他们的争斗，也是如此，为了自由而战。也明白了为什么UDP协议既然是不安全的，都用TCP协议不就好了，因为UDP轻量，方便自己去定制。 markdown的一些语法markdown让文字居中和带颜色]]></content>
  </entry>
</search>
