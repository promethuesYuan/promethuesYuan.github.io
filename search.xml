<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flink之window介绍及API]]></title>
    <url>%2F2020%2F03%2F12%2FFlink%E4%B9%8Bwindow%E4%BB%8B%E7%BB%8D%E5%8F%8AAPI%2F</url>
    <content type="text"><![CDATA[介绍window这个概念以及相关的API函数 window概念 真实的流为无界的流,如何进行处理? 可以把无限的数据流进行划分,得到有限的数据集进行处理,也就是有界流 窗口,就是将无界流切割为有界流的一种方式,它会把流数据分发到有限大小的桶中进行分析 window类型 时间窗口(Time Window) 滚动时间窗口 滑动时间窗口 会话窗口 计数窗口(Count Window) 滚动计数窗口 滑动计数窗口 滚动窗口(Tumbling Window) 将数据依据固定的窗口长度对数据进行切分 时间对齐,窗口长度固定,无重叠部分 一个数据只能划分到一个确定的窗口 滑动窗口(Sliding Window) 滑动窗口是固定窗口的更广义的一种形式,由固定的窗口长度和滑动间隔组成 窗口长度固定,可以有重叠 会话窗口(Session Window) 由一系列事件组成一个指定时间长度的timeout间隙组成,也就是一段时间没有接收到新数据就会生成新的窗口 特点:时间无对齐 window API 窗口分配器–window()方法.该方法必须在keyBy之后才能使用 更简单调用为.timeWindow和.countWindow方法,用于定义时间窗口和计数窗口 window assigner window()方法接受的输入参数是一个window assigner.它负责将输入的数据分发到正确的window中 通用的window assigner: 滚动窗口(tumbling window) 滑动窗口(sliding window) 会话窗口(session window) 全局窗口(global window) 创建不同类型的窗口 滚动时间窗口 .timeWindow(Time.seconds(15)) 滑动时间窗口 .timeWindow(Time.seconds(15), Time.seconds(5)) 会话窗口 .window(EventTimeSessionWindows.withGap(Time.minutes(10))) 滚动计数窗口 .countWindow(5) 滑动计数窗口 .countWindow(10, 2) 窗口函数(window function)定义要对窗口中收集的数据做计算操作 增量聚合函数 每条数据到来就进行计算,保持一个简单的状态 reduce aggregate 全窗口函数 先把窗口所有数据收集起来,等到计算的时候会遍历所有数据 process 其他可选API API 作用 .triger() 定义window什么时候关闭,触发计算并输出结果 .evitor() 定义移出某些数据的逻辑 .allowedLateness() 允许处理迟到的数据 .sideOutputLateData() 将迟到的数据放入侧输出流中 .getSideOutput() 获取侧输出流]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2020%2F03%2F11%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[回顾基本的排序算法 排序算法基本（做到快速无bug写出） 冒泡排序 插入排序 常考 归并排序 快速排序 拓扑排序 其他（开拓思路） 堆排序 桶排序 冒泡排序空间复杂度:O(1) 时间复杂度:O(n^2) 稳定 插入排序空间复杂度:O(1) 时间复杂度:O(n^2) 稳定 归并排序核心思想：分治 12345678910111213141516171819202122232425262728293031323334353637/** * 升序排列int数组 * @param A:需要排列的数组 * @param lo:数组起始下标 * @param hi:数组结束下标 */public static void mergeSort(int[] A, int lo, int hi)&#123; //升序方式排列数组 //如果lo&gt;=hi,说明数组中只有一个元素，应该返回 if(lo &gt;= hi) return; //取中位数 int mid = lo + (hi-lo)/2; //左右递归两遍的数组 mergeSort(A, lo, mid); mergeSort(A, mid+1, hi); //递归结束,进行合并 merge(A, lo, mid, hi); &#125; private static void merge(int[] nums, int lo, int mid, int hi)&#123; //复制原来的数组 int[] cp = nums.clone(); //k表示从什么位置修改原来的数组,i是左边开始的起始位置,j是右边开始的起始位置 int k = lo, i = lo, j = mid+1; while (k &lt;= hi)&#123; //如果左边已经放置完了,就直接放置右边剩下的 //如果右边已经放置完了,就直接放置左边剩下的 //如果左边大于右边,则放置右边,否则放置左边. if(i &gt; mid) nums[k++] = cp[j++]; else if(j &gt; hi) nums[k++] = cp[i++]; else if(cp[i] &gt; cp[j]) nums[k++] = cp[j++]; else nums[k++] = cp[i++]; &#125; &#125; 时间复杂度:O(nlogn) 空间复杂度:O(n) 稳定 快速排序123456789101112131415161718192021222324252627282930/** * 升序排列int数组 * @param nums:需要排列的数组 * @param lo:数组起始下标 * @param hi:数组结束下标 */public static void quickSort(int[] nums, int lo, int hi)&#123; //如果只有一个元素了,则返回 if(lo &gt;= hi) return ; //获取参照值 int p = partition(nums, lo, hi); //把比p小的放到左边,比p大的放到右边 quickSort(nums, lo, p-1); quickSort(nums, p+1, hi);&#125;private static int partition(int[] nums, int lo, int hi)&#123; int tmp = nums[lo]; while (lo &lt; hi)&#123; while (lo &lt; hi &amp;&amp; nums[hi] &gt; tmp) hi--; nums[lo] = nums[hi]; while (lo &lt; hi &amp;&amp; nums[lo] &lt; tmp) lo++; nums[hi] = nums[lo]; &#125; nums[lo] = tmp; return lo; //返回中轴位置&#125; 时间复杂度:O(nlogn) 空间复杂度:O(n) 稳定]]></content>
      <categories>
        <category>面试复习</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习数据结构]]></title>
    <url>%2F2020%2F03%2F10%2F%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[重温数据结构，开始刷题 常用数据结构和技巧 数组、字符串 链表 栈 队列 双端队列 树 字符串字符串的处理更多的是转换成字符数组对每一个字符进行处理。 链表单链表：链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。 双链表：单链表不同的是，双链表的每个结点中都含有两个引用字段。 解题技巧： 利用快慢指针。典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。 构建一个虚假的链表头 训练技巧：在白板上画出节点之间的相互关系，画出修改的方法 栈由于历史遗留问题，Java中没有Stack接口，通过Deque接口来模拟Stack。 当我们把Deque作为Stack使用时，注意只调用push()/pop()/peek()方法，不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰。 队列 int size()：获取队列长度； boolean add(E)/boolean offer(E)：添加元素到队尾； E remove()/E poll()：获取队首元素并从队列中删除； E element()/E peek()：获取队首元素但并不从队列中删除。 添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。 throw Exception 返回false或null 添加元素到队尾 add(E e) boolean offer(E e) 取队首元素并删除 E remove() E poll() 取队首元素但不删除 E element() E peek() 双端队列特点：双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。 实现：与队列相似，我们可以利用一个双链表实现双端队列。 应用场景：双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目里都有运用。 我们来比较一下Queue和Deque出队和入队的方法： Queue Deque 添加元素到队尾 add(E e) / offer(E e) addLast(E e) / offerLast(E e) 取队首元素并删除 E remove() / E poll() E removeFirst() / E pollFirst() 取队首元素但不删除 E element() / E peek() E getFirst() / E peekFirst() 添加元素到队首 无 addFirst(E e) / offerFirst(E e) 取队尾元素并删除 无 E removeLast() / E pollLast() 取队尾元素但不删除 无 E getLast() / E peekLast() Deque是一个接口，它的实现类有ArrayDeque和LinkedList。 树在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。 重点复习一下树的遍历问题。 高级数据结构 优先队列 图 线段树 前缀树 树状数组 高级数据结构的内容过于陌生，留到后面学习整理。先巩固基础的数据结构。]]></content>
      <categories>
        <category>面试复习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pravega项目初试]]></title>
    <url>%2F2020%2F03%2F03%2FPravega%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一个简单的Pravega项目 Pravega中的event读取行为分别由writer &amp; reader端来实现，下面就从这两个方面来入手分析。 项目介绍一个简单的读写程序，Writer端一直等待输入，每次获得字符串后写入event。当读到”EXIT”时，写入并退出。Reader端持续读取event,每读到一个event，就把它输出并且统计其大小写出现的次数。当收到”EXIT”时，程序退出。 Writer1.一些定义12345final String scope = "mytest";final String streamName = "helloStream";final String uriString = "tcp://127.0.0.1:9090";final URI controllerURI = URI.create(uriString);final String routingKey = "helloRoutingKey"; 首先是一些string的设置，用于在后面定义scope和stream。 每一个事件都有一个Routing Key。Routing Key是开发者用于把相似的事件定位一个组的字符串。Routing Key通常由事件中产生，如“customer-id”,”machine-id” ,或者是开发者自己定义的一个字符串。Routing Key 2.创建Scope &amp; Stream123456StreamManager streamManager = StreamManager.create(controllerURI);boolean scopeIsNew = streamManager.createScope(scope);StreamConfiguration streamConfig = StreamConfiguration.builder() .scalingPolicy(ScalingPolicy.fixed(1)) .build();boolean streamIsNew = streamManager.createStream(scope, streamName, streamConfig); 创建scope和stream都需要由StreamManager来创建。首先先通过controllerURI来创建streamManager。创建scope时，创建成功则返回true，否则返回false。StreamConfiguration是用来设定stream的相关属性的，scalingPolicy(ScalingPolicy.fixed(1))就是定义stream中segment数目固定为1.创建stream时，需要scope, streamName, streamConfig三个参数，创建成功则返回true，否则返回false。 3.Write event12345678910111213141516171819try (ClientFactory clientFactory = ClientFactory.withScope(scope, controllerURI);EventStreamWriter&lt;String&gt; writer = clientFactory.createEventWriter(streamName, new JavaSerializer&lt;String&gt;(), EventWriterConfig.builder().build())) &#123; Scanner sc = new Scanner(System.in); System.out.printf("please input:"); while (sc.hasNextLine()) &#123; String s = sc.nextLine(); if (s.equals("EXIT")) &#123; writer.writeEvent(routingKey, s); System.out.println("**** Exitting.."); System.exit(1); &#125; System.out.println("*** " + s); writer.writeEvent(routingKey, s); System.out.printf("please input:"); &#125;&#125; writer的创建需要通过ClientFactory来实现，ClientFactory其需要scope, controllerURI这两个属性。createEventWriter创建时需要定义： 往哪个stream里写 序列化的方式，前后一致 配置属性（此处为默认属性） 写事件时，使用writer.writeEvent(routingKey, s)将event写入stream中，注意要加上Routing Key. Reader1.一些定义123456final String scope = "mytest";final String streamName = "helloStream";final String uriString = "tcp://127.0.0.1:9090";final URI controllerURI = URI.create(uriString);final String routingKey = "helloRoutingKey";final int READER_TIMEOUT_MS = 1000; 和writer一致的定义不再赘述，这里多了一个READER_TIMEOUT_MS,在后面读事件时候解释。 2.创建ReaderGroup12345678final String readerGroup = "helloReaderGroup";final ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder() .stream(Stream.of(scope, streamName)) .build();try(ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scope, controllerURI))&#123; readerGroupManager.createReaderGroup(readerGroup, readerGroupConfig);&#125; reader group通过ReaderGroupConfig, ReaderGroupManager来创建。 3.Read event123456789101112131415161718192021222324252627282930313233343536373839try(ClientFactory clientFactory = ClientFactory.withScope(scope, controllerURI); EventStreamReader&lt;String&gt; reader = clientFactory.createReader("myreader",readerGroup, new JavaSerializer&lt;String&gt;(),ReaderConfig.builder().build()))&#123; EventRead&lt;String&gt; event = null; System.out.println("Reader is ready."); while(true)&#123; try&#123; event = reader.readNextEvent(READER_TIMEOUT_MS); if(event.getEvent() != null)&#123; String res = event.getEvent(); if(res.equals("EXIT")) break; int[] upperCase = new int[26]; int[] lowerCase = new int[26]; for(int i=0; i&lt;res.length(); i++)&#123; char c = res.charAt(i); if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') lowerCase[c-'a']++; else if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') upperCase[c-'A']++; &#125; System.out.println("Read event: " + res); for(int i=0; i&lt;26; i++) &#123; if(lowerCase[i] != 0)&#123; System.out.printf("%c:%d ", 'a'+i, lowerCase[i]); lowerCase[i] = 0; &#125; &#125; for(int i=0; i&lt;26; i++) &#123; if(upperCase[i] != 0)&#123; System.out.printf("%c:%d ", 'A'+i, upperCase[i]); upperCase[i] = 0; &#125; &#125; System.out.println(); &#125; &#125; catch(ReinitializationRequiredException e)&#123; e.printStackTrace(); &#125; &#125;&#125; reader的创建，需要通过ClientFactory，创建时候需要定义： reader的名字 reader所属的reader group 反序列化的方式 配置属性（此处为默认属性） 读事件的时候，由reader.readNextEvent(READER_TIMEOUT_MS)来读取事件，此处的READER_TIMEOUT_MS就是我们在1中所定义的。如果当前没有event了，将会阻止等待事件的继续到来，READER_TIMEOUT_MS就是等待事件的上限。 当没有事件到来，event.getEvent()的值就是null，否则就是指向通过反序列化得到的实例。]]></content>
      <tags>
        <tag>Pravega</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库:事务概念]]></title>
    <url>%2F2020%2F02%2F29%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[介绍数据库中事务这个概念 之前遇到过事务这个概念，在做pravega的时候有个名词叫做trasaction，英语不太懂，查了之后发现原来就是事务的意思，顺便再学习一下到底什么是“事务”。内容整理自百度百科 1.定义数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 2.理解对于数据库，我们进行的操作无非就是CRUA，事务是工作的离散单位。在单用户、单数据库下执行事务比较简单，但在分布式环境下，维护多个数据库的完整性就比较复杂。一个事务再多个场地进行修改，那就需要管理机制来防止数据重写并提供同步。另外还需要具有返回失效事务的能力，提供安全保障和提供数据恢复能力。 比如，我们去银行转账，操作可以分为下面两个环节： 从第一个账户划出款项。 将款项存入第二个账户。 在这个过程中，两个环节是关联的。第一个账户划出款项必须保证正确的存入第二个账户，如果第二个环节没有完成，整个的过程都应该取消，否则就会发生丢失款项的问题。整个交易过程，可以看作是一个事物，成功则全部成功，失败则需要全部撤消，这样可以避免当操作的中间环节出现问题时，产生数据不一致的问题。 我们可以这样理解数据库事物:对数据库所做的一系列修改，在修改过程中，暂时不写入数据库，而是缓存起来，用户在自己的终端可以预览变化，直到全部修改完成，并经过检查确认无误后，一次性提交并写入数据库，在提交之前，必要的话所做的修改都可以取消。提交之后，就不能撤销，提交成功后其他用户才可以通过查询浏览数据的变化。 3.性质（ACID） 原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。 一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致。 夺隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。 夺持久性(Durability):对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 百度给的这个一致性的解释看的我很懵逼啊，于是又查询了相关资料，数据库中一致性准确定义为： Consistency ensures that a transaction can only bring the database from one valid state to another, maintaining database invariants: any data written to the database must be valid according to all defined rules, including constraints,cascades,triggers, and any combination thereof. 一致性确保事务只能把数据库从一个有效的状态带到另一个有效的状态，保持数据库的不变性:任何写入到数据库的数据都需要按照已经定义的规则为有效的，包括约束、级联、除法器及其任意组合。 举一个例子，一个银行系统，内部在进行转账的过程中，金钱总量保持不变是其定义的规则。那么A转了100给B，就必须A-100,B+100，使其金钱总量不变，处于一个有效的状态。]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2020%2F02%2F18%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录Linux学习过程中学到的命令与用法 Linux学习笔记文件和目录管理文件类型 - 普通文件 d 目录 b 块设备文件，保存大块数据的设备，如硬盘 c 字符设备文件，如键盘鼠标 s 套接字文件，用于网络数据连接 p 管道文件，作用是解决多个程序同时存取一个文件所造成的错误 l 链接文件，软链接 cd 切换目录 ~ 当前登录用户主目录 ~用户名 切换到指定用户的主目录 上次所在的目录 . 当前目录 .. 上一级目录 / 根目录 pwd 显示当前工作路径（常用）ls 查看目录中的文件 ls [选项] 目录名称 常用选项 -a 显示全部的文件，包括隐藏文件（开头为 . 的文件）也一起罗列出来，这是最常用的选项之一。 -A 显示全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录。 -l 使用长格式列出文件和目录信息。 -h 以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。 -R 连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。 mkdir 创建目录 -p 选项递归建立目录。 如：mkdir -p lm/movie/jp/cangls -m 选项自定义目录权限。 如：mkdir -m 711 test2 rmdir 删除目录 也可以用-p选项递归删除，但是只能删除空目录，作用非常小，顾不常用 touch 创建文件ln 文件之间建立软/硬链接 ln [选项] 源文件 目标文件 -s：建立软链接文件。如果不加 “-s” 选项，则建立硬链接文件； -f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件； cp 复制文件和目录 cp [选项] 源文件 目标文件 常用选项 -r：递归复制，用于复制目录； -a：相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍； -p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；目的：我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。 -i：询问，如果目标文件已经存在，则会询问是否覆盖； -d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接； -l：把目标文件建立为源文件的硬链接文件，而不是复制源文件 -s：把目标文件建立为源文件的软链接文件，而不是复制源文件 分支主题 2分支主题 3XMind: ZEN - Trial Version]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下C程序获得shell脚本输出]]></title>
    <url>%2F2020%2F02%2F17%2FLinux%E4%B8%8BC%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%BE%97shell%E8%84%9A%E6%9C%AC%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[shell脚本输出结果重定向 课设里面，需要查看系统的相关信息。指导书上直接打开文件来获得，但我发现通过terminal中的一些命令更容易获得自己想要的信息，于是就研究如何把终端中输出的结果重定向过来。 使用popen 1FILE *popen(const char *command, const char *type); 该函数的作用是创建一个管道，fork一个进程，然后执行shell，而shell的输出可以采用读取文件的方式获得。采用这种方法，既避免了创建临时文件，又不受输出字符数的限制。 123#include &lt;stdio.h&gt; //头文件FILE *popen(const char *command, const char *type);int pclose(FILE *stream); popen 通过type是r还是w确定command的输入/输出方向，r和w是相对command的管道而言的。r表示command从管道中读入，w表示 command通过管道输出到它的stdout，popen返回FIFO管道的文件流指针。pclose则用于使用结束后关闭这个指针。 下面看一个示例，将free -m命令输出情况重定向输出到buf中，方便处理。 1234567891011121314151617181920#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;int main( void ) &#123; FILE *stream; char buf[1024]; memset( buf, '\0', sizeof(buf) ); stream = popen( "free -m", "r" ); fread( buf, sizeof(char), sizeof(buf), stream); printf("%s\n", buf); pclose( stream ); return 0;&#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux重装后必做!]]></title>
    <url>%2F2020%2F02%2F16%2FLinux%E9%87%8D%E8%A3%85%E5%90%8E%E5%BF%85%E5%81%9A%2F</url>
    <content type="text"><![CDATA[最近重装好几次Ubuntu了，每次重装后都有些准备工作要做，老是得上网查，这里记录一下所有步骤。 1. 安装openssh-service安装这个是为了用Xshell等连接工具连接到我们的虚拟机，使用终端界面。因为VM虚拟机里无法把主机的内容复制粘贴进去，装了VM Tools才行，所以现在用连接工具比较多。使用下面的命令安装openssh-service： 1sudo apt-get install openssh-server 安装完毕后，查看本机的ip，之后就可以通过连接工具登录啦。 2. 修改镜像源ubuntu默认使用的是外国的镜像源，下载速度巨慢无比，务必换成国内镜像源。我通常使用的是阿里的镜像源，使用其他的也可。 首先先备份本地的源文件，位置在/etc/apt/sources.list 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bk 然后用vim打开，源文件，将国内镜像粘贴进去。 1sudo vi /etc/apt/sources.list Ubuntu 18.04 LTS 阿里云镜像 123456789101112131415# https://opsx.alibaba.com/mirrordeb https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse # 仿照清华镜像源，注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释# deb-src https://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 最后更新列表 12sudo apt-get updatesudo apt-get upgrade 3. 安装vimUbuntu不知道为什么，默认安装的vim是个残次品，用起来相当难受，所以安装一下完整版的vim。 1sudo apt install vim 4. 息屏123456关闭息屏，最后0是代表关闭锁屏，将0替换为60代表60s后自动息屏，以此类推。gsettings set org.gnome.desktop.session idle-delay 0 关闭锁屏gsettings set org.gnome.desktop.screensaver lock-enabled false 5. gcc1sudo apt install gcc]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xshell中显示用户名和主机颜色]]></title>
    <url>%2F2020%2F02%2F15%2FXShell%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E4%B8%BB%E6%9C%BA%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[最近开始用Xshell连接虚拟机，虽然Xshell可以更改配色方案，终端中默认不显示用户名和主机名的颜色，命令一多，非常难以辨认。于是记录一下如何使用户名和主机名显色。 修改用户目录下的.bashrc文件 通过vi打开该文件，vi ~/.bashrc 在文件稍微靠后的位置找到这么一句话，# force_color_prompt=yes , 把注释注销掉，保存退出 加载文件。source ~/.bashrc 然后就可以看到Xshell终端中用户名和主机名颜色变成主题对应的颜色了。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim简单入门]]></title>
    <url>%2F2020%2F02%2F12%2Fvim%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[vim快速上手了一下，记忆一些简单的指令和操作 1.移动光标h j k l 上：k 下：j 左：h 右：l 2.模式普通模式和插入模式 敲击按键 含义 i 在光标前进入插入模式 I 在光标所在行的行首进入插入模式 a 在光标的后边进入插入模式 A 在光标所在行的行尾进入插入模式 o 在光标所在行的下方插入空行并进入插入模式 O 在光标所在行的上方插入空行并进入插入模式 s 删除光标指定的字符并进入插入模式 S 将光标所在行清楚并进入插入模式 3.删除命令普通模式下，删除单一字符可以使用x命令，删除更多字符可以使用d命令 motion–表示操作范围的指令 按键 含义 0 将光标定位到行首的位置 ^ 同上 $ 将光标定位到行尾的位置 b 将光标定位到光标所在单词的起始处 e 将光标定位到光标所在单词的结尾处 w 将光标定位到下一个单词的起始处 gg 将光标定位到文件的开头 G 将光标定位到文件的末尾 -d motion可以组成更多的删除命令 按键 含义 d0 删除光标从当前位置（不包含）到该行行首的所有字符 d^ 同上 d$ 删除从光标当前位置（包含）到该行行尾的所有字符 db 删除从光标当前位置（不包含）到该单词起始处的所有字符 de 删除从光标当前位置（包含）到单词结尾处的所有字符 dw 删除从光标当前位置（包含）到下一个单词起始处的所有字符 dh 删除光标前边一个字符 dl 删除光标制定的字符 dj 删除光标所在行以及下一行的所有字符 dk 删除光标所在行以及上一行的所有字符 dd 删除光标所在行的字符 dgg 删除光标所在行到文件开头的所有字符 dG 删除光标所在行到文件末尾的所有字符 数字 + motion = 重复多个motion d + 数字 + motion = 删除多个motion范围 4.撤销 u表示撤销最后一次修改 U表示撤销对整行的修改 ctrl + r 可以恢复撤销的内容 5.粘贴 按键 含义 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) 命令c = 命令d + 进入删除模式 6.查看文件信息 按键 含义 ctrl + g 在底栏显示文件信息 行号+G / :行号 跳转到该行 % 找到另一半括号 &lt;&lt; / &gt;&gt; 左右缩进 7.搜索 /目标 ?目标 搜索方向 从光标开始向后 从光标开始向前 n 向后搜索下一个 向前搜索下一个 N 向前搜索下一个 向后搜索下一个 十个特殊字符需加转义符’\‘进行搜索：. * [ ] ^ % / ? ~ $ 8.文件操作 按键 含义 :w filename 文件另存为 :r filename 将别的文件合并到该文件中 vi -o 或 -O 打开多个文件，小写竖向排列，大写横向排列 ctrl + ww 打开多个文件时进行切换窗口 9.显示行号在当前文件输入命令 :set nu，即显示行号，:set nonu则为取消。该方法只为临时显示行号，下次打开时同样没有。 永久显示行号 在命令行输入vim ~/.vimrc ，即进入配置文件vimrc中，加入set nu， 保存退出，就可永久显示行号]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电话面记录与心得]]></title>
    <url>%2F2019%2F12%2F16%2F%E7%94%B5%E8%AF%9D%E9%9D%A2%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[第一次小的电话面，紧张到不行，很有收获。 1.面试记录 刚上来就问我，觉得学的比较好的课程有哪些。有点懵逼，好像没有什么学的特别好的课程啊，就只能往专业课这边靠，说算法与数据结构还行（才70+分，菜…），还说了个刚学的计算机网络。然后刘哥就就着算法与数据结构开问了，心里慌得一批。先问了最简单的排序问题，这个真的看过很多遍，但有些算法比如快排，堆排，没有真正的理解。第一个问题是什么时候快排的效率会低于冒泡，这个之前洛谷做题遇到过，就答得从容。第二个问题是给一个数组，里面有奇数偶数，设计一种算法将奇数放到队列前面，偶数放到队列后面。一听到这个题目我的第一反应就是用两个队列，作为奇偶数的存放区域，然后遍历一遍，分别入队，再合并就行了。然后刘哥问我还有别的思路没，我就卡住了……他提示说用快排的思路，我倒是知道快排可以这么做，就是有点说不清楚，就不太敢说。再进一步他就问快排会使得队列不稳定，设计一种算法使得最后队列依然稳定。这个我确实想不出来，他让我别那么急着放弃orz。不过他后来说的算法我感觉也有问题啊QAQ ​ 数据结构问完后，就问了一下计网的东西。第一个问题问的是什么为了实现负载均衡与高可用性，应该在哪一层怎么怎么样。这个8知道，就直说了，也没有做过web应用，不了解啊。然后就问了个很基础的ping是在哪一层，用的什么协议。啊，当时真的脑子卡壳了，也真的有点忘了Ping的具体用法，就说不太清楚。他说ICMP，我就突然想起来了。害，还是基础知识有些不够啊。 ​ 因为之前电话聊的时候，我有跟他说现在在实验室做的ceph项目（虽然我都还没实际参与到其中……），然后他就问除了这个还有什么竞赛项目经历吗。本来我说的没有，突然想起来暑假做的爬虫工作，然后就提起这个了（我为什么要提。。），就悲催了。本来想着是显示有更多经历的，但真的，我这些经历都没做到什么实际工作，也只是别人安排我做什么我就去做，没有主观能动性，所以当他问一些项目背景啊什么的，我真的都不太知道。看我答得这么混乱，他就让我一句话总结一下项目背景与意义、以及我在其中做的工作。强行总结了一通，越说越心虚。刘哥也对我的情况评价了一下，这个放到心得处讲。 ​ 电话面情况差不多就是这样了，本来以为只是一个简单的外包工作，没想到还会有这么多事。不过这个也很正常，别人不可能完全不了解你，就把工作交给你了。也发现了自己现在欠缺的东西还很多，加油学啊。 2. 面试心得 算法与数据结构继续深度学习。这个真的是不管学哪门语言，用什么技术，都躲不开的话题。今天问的问题都这么简单我答得还那么烂，这方面的技术积累真的不行。算法方面，今年这门算法课我也感觉自己这个地方学的很不行，动态规划啊，分治啊什么的，理解不到位，代码也不会写，有时间一定要学起来。 总结你的项目经历！之前看羊哥讲面试的视频，里面说那些自己不熟的项目千万不要写在简历上，要写就写那些你最熟悉，最能体现你技术水平的项目。听的时候不以为意，轮到自己面试的时候才发现真的是这样的。对项目不了解，也没做什么具体贡献，只会让你的回答非常糟糕。刘哥也给出了具体的建议：不管做什么项目，只要参与其中了，就一定要明确项目需求，思考这个项目为什么成立。只有明确项目背景后，明白其architecture，才能发挥自己的主观能动性，在项目中做出更多的贡献，能更好地提高自己，建立自己的reputation。 大三上都快要过完了，不能在这么混下去了。要逐步建立自己的技术栈，总结自己的项目经历，不然找工作的话简历都写个 :hammer: 啊。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近的编程感悟]]></title>
    <url>%2F2019%2F12%2F03%2F%E6%9C%80%E8%BF%91%E7%9A%84%E7%BC%96%E7%A8%8B%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[近日编程小感 伤病归来，接连的实验，忙于应付，感觉有些疲惫。不过从最近的poj实验和计网实验，也有一些编程的小感悟，随手记一下。 编程是个手艺活 伤病了大概一个多星期吧，这期间基本就没有写过代码。住院的时候确实有疼到没办法写，但没什么大碍的时候我都在那儿玩游戏。所以伤好归来，开始写代码了，感觉自己特别生疏，简单的c++代码差点不知道怎么开头写了。 虽然这是个很小的事情，但我觉得还是很有警示作用。本来自己的代码量就不是很够，平时在一疏忽，写的代码就少之又少。而写代码本身就是一个手艺活，写的越多，思考的越多，才能写的更好。还是得继续加油啊。 思考 &gt;&gt; 写代码 以前数据结构老师说，写代码重要的是把思路搞清楚，思路理顺了，代码实现起来就是轻而易举的事。之前我没有明白这句话的意义，在第二次计网实验彻底懂了。 这次实验的一开始，我也像之前写代码一样，感觉对算法理解的差不多，在脑海里大概推演一下，是那么回事，就开始敲代码了。然而，我越写代码，就越感觉思维的混乱。一段代码写了又删，不停的对算法有新的认识，不停地推翻之前写的错误版本。到最后觉得不停的改实在太累了，就把原来写的全部推到重来，实现起来却很快，思路异常清晰，逻辑严谨。后来仔细想一下，我省在思考算法上的时间，最后还是一点都没省下来。 有了这次教训，在后面实现SR协议的时候，我花了一个多小时来认真思考这个算法，详细考虑每一个步骤该怎么处理，设计与之相匹配的数据结构。最后落实到代码实现上，真的感觉就是把我写在纸上的那些东西变成了代码而已，相当轻快。 学习中，勤思，否则将成为代码的搬运工。]]></content>
      <categories>
        <category>编程感悟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用命令行查询电池损耗]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%94%B5%E6%B1%A0%E6%8D%9F%E8%80%97%2F</url>
    <content type="text"><![CDATA[xps13电池损耗严重，windows下在cmd中可以很方便的查询电池现况，用过很多次了，记录一下。 以管理员身份运行cmd 输入命令：powercfg /batteryreport /output &quot;C:\battery_report.html&quot; 上面这段命令会生成一个电池报告，路径就在上面，该路径也可以自己定制。前往该路径打开html文件即可查看电池现况。 用了两年的xps13，之前电池还挺耐用的，一般去图书馆都不用带充电器，现在不得不带上了。用电池30min掉了20%，真的难顶啊，实在不行就只能去换一块电池了 :sob:]]></content>
      <categories>
        <category>电脑使用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++知识点清单]]></title>
    <url>%2F2019%2F10%2F18%2FC-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[C++不熟悉知识点学习记录 TOLEARN List 访问限制 虚函数、友元函数、析构函数 运算符重载 多重继承]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP:字符画 总结]]></title>
    <url>%2F2019%2F10%2F16%2FCSP-%E5%AD%97%E7%AC%A6%E7%94%BB-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[考试时候毫无头绪，平时自己静下心来写还花了两三个小时，CSP真的不简单啊。现在来总结总结这个题，看看到底是哪里难到了我。 吐槽 题目解释的时候，用正常的序列在那儿解释，到了题目输出的时候，直接变成了ASCII码，人都给我看傻了。主要是没有ASCII码对照表，当时人一懵，就看不懂他写的啥意思了。然后题目中的48，ASCII中竟然是把4和8分开输出的，当时就找了好半天，感觉这输出和题目说的对不上呢。 题目中讲了38来修改字的颜色，48来修改背景的颜色，讲了一大堆，到了后面发现只用修改背景颜色。害，废话真多。 原来题目长的原因就是因为废话太多。 总之，我太菜了😵 思路 ​ 其实如果冷静读题，能把题目中那么多废话刨开，然后把ASCII码和结果对应搞明白，这个题并不是很难的。总的流程无非就是输入所有的RGB配色，然后通过分块的方式进行每一块RGB计算（感觉当时写数独对分块操作颇有心得）。然后再是按照分块的顺序，通过双循环来输出就行了。 zz错误以及一些重要的坑！ 最最重要的一个错误 : 在输出反斜杠(\) 时，没有采用忘记需要通过转义序列来输出，导致最开始无法输出结果。也是懵逼了好久才发现这个错误。与此相类似的是输出单引号(‘)和双引号(“)时也需要转义序列，以后要注意。 在处理RGB到字符串的时候，开始是分号的位置放置的不合适。后来是发现对单个颜色值的每一位，我前面都加了一个分号，这样是不对的，应该只用在最高位前面加一个分号即可，感觉当时写糊涂了。 每一行的末尾开始的时候忘记判断是否需要重置。重置之后发现自己又多加了一个空格，导致出错。 重要tips:写程序的时候，尤其这种题目长，比较复杂的模拟题，理清题目很重要。用草稿纸和画图的方式来加快自己的理解。并且尽量把自己处理的步骤以及边界条件罗列下来，防止自己脑抽。在coding的过程中，最好还是多写一点注释，这样能提醒自己，我现在做到哪一步了，可以更加明确处理的思路，然后也能提醒自己当时写的对应位置的特殊情况。也方便自己出错的时候回来检查。 申明全局变量：在程序中，那种放置大量元素的结构，尽量声明为全局变量，大小可以根据题目提示的数据范围，选择最大的即可。之前我一直觉得，一开始就声明一个那么大的何必呢，根据题目的输入来声明对应大小不久可以了，然鹅这道题让我意识到了全局变量的重要性。因为全局变量存储在自由分配区，而局部变量存储在栈区。按照室友的说法，一般这种考试，你声明的全局变量基本都装得下，但是如果你声明的是局部变量，那么栈的空间是有限的，运行的时候就可能出现栈满这种情况，导致运行错误。所以还是尽管使用全局变量吧。 说点没用的 ​ CSP这段时间刷了一些第三题/第四题，一方面感觉CSP确实挺难的，但另一方面也发现自己还是有能力做出来这些题的。经过这段时间的练习，感觉做题能力有了一点提高，对C++做题的使用也更熟练了。所以继续加油吧！后面做题尽量自己写一些测试用例，毕竟考试的时候没办法提交看到你跑出来的结果呀。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++之list]]></title>
    <url>%2F2019%2F10%2F15%2FC-%E4%B9%8Blist%2F</url>
    <content type="text"><![CDATA[记录C++中list的用法 list的实现list是 每个节点包含前继节点，后继节点，数据域三部分的双向循环链表。和普通链表性质一样，不提供随机访问，访问时间复杂度为0(n)，适合插入和删除。 头文件#include&lt;list&gt; list包含的函数1.声明list list list1; // 声明一个空的list1 list list3 (list2.begin(), list2.end()); // 用list2的迭代器内容声明list3 list list4 (list3); // 声明list4为list3的一个副本 list1.~list(); // 注销list 2.访问元素 list.front(); //返回第一个元素的值 list.back(); //返回最后一个元素的值 list.begin(); //返回第一个元素的迭代器 list.end(); //返回最后一个元素的迭代器 遍历 123456list&lt;int&gt; a;list&lt;int&gt;::iterator iter = a.begin();//或者 auto iter = a.begin();while(iter!=a.end())&#123; cout&lt;&lt; *iter++ &lt;&lt;endl;&#125; 3.添加、删除元素 list.pop_front(); //删除第一个元素 list.pop_back(); //删除最后一个元素 list.clear(); //清空list list.insert(iter, t); //在iter之前插入元素t list.erase(iter, t); //删除iter处的元素 如何控制iter位置： 123auto iter = a.begin();srd::advance(iter, 10); //将iter往后移10位a.erase(iter); //此时删除的就是第十一个元素 4.排序 list.sort(); //默认升序排序 list.reverse(); //将list元素反转]]></content>
      <categories>
        <category>解题记录</category>
      </categories>
      <tags>
        <tag>C++, list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[printf与十六进制]]></title>
    <url>%2F2019%2F10%2F06%2Fprintf%E4%B8%8E%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[如何用printf输出十六进制 CSP里面用到十六进制的地方还是挺多的，所以记录一下如何输出十六进制数据。 12345int a = 0xf;printf("%x\n", a); //x为小写时，输出a~fprintf("%X\n", a); //注意这里的X为大写，输出时A~F为大写printf("%4x\n", a); //补齐为4位，左边补空格printf("%04x\n", a); //补齐为4位，左边补0 结果 1234fF f000f]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高效率:cin和cout]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87-cin%E5%92%8Ccout%2F</url>
    <content type="text"><![CDATA[做题还是少用cin/cout,转用scanf/printf吧 今天做CSP：190303_RAID5这个题的时候，第一版做完结果30分，运行超时。费劲心思优化之后，还是一样的结果。不知道怎么优化后，去网上查别人的解法。看别人代码的时候主意到了这么一句话 1std::ios::sync_with_stdio(false);//避免c++中cin操作超时。 觉得可能跟这个原因有关，于是在代码中加上了上面这句话，于是就AC了…小伙感觉非常震惊，于是去网上了解详情。 博客解释 cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几，还有应注意的是scanf与printf使用的头文件应是stdio.h而不是iostream。 sync_with_stdio函数是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将输出流绑到了一起。 所以以后要是大型输入输出时候，采用cin/cout还是需要加上这句话来提速。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的用法:记一道LeetCode题目]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%A0%88%E7%9A%84%E7%94%A8%E6%B3%95-%E8%AE%B0%E4%B8%80%E9%81%93LeetCode%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[周赛中遇到的一道活用栈的题目，比较有启发意义。 题目 5206. 删除字符串中的所有相邻重复项 题目描述 给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。在执行完所有删除操作后，返回最终得到的字符串。本题答案保证唯一。 示例 输入：s = “deeedbbcccbdaa”, k = 3输出：”aa”解释： 先删除 “eee” 和 “ccc”，得到 “ddbbbdaa”再删除 “bbb”，得到 “dddaa”最后删除 “ddd”，得到 “aa” 数据结构：栈 解法：将字符串的每个字符按照顺序依次进站，如果栈中已经有k个相同的字符，就将他们依次弹出。最后将栈中剩余的字符串按照反序连接起来输出即得到正确答案。 启发：之前学了数据结构，但是感觉自己并没有用到解题中，没有这种思考的意识。本来自己在想怎么解的时候，一直在思考如何对字符串进行操作，听到别人解析用栈来实现的时候，觉得恍然大悟。所以还是数据结构基础要打好，然后就是如何灵活应用这些数据结构来解决问题。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041import javafx.util.Pair;import java.util.Stack;class Solution &#123; public String removeDuplicates(String s, int k) &#123; /** *Pair用来记录当前字符以及这个字符是第几个了 */ Stack&lt;Pair&lt;Character, Integer&gt;&gt; stack = new Stack&lt;&gt;(); Pair&lt;Character, Integer&gt; pair = new Pair&lt;Character, Integer&gt;(s.charAt(0), 1); stack.push(pair); int len = s.length(); for(int i=1; i&lt;len; i++)&#123; if(!stack.isEmpty())&#123; char temp = stack.peek().getKey(); int num = stack.peek().getValue(); if(temp == s.charAt(i))&#123; stack.push(new Pair&lt;&gt;(temp, num+1)); if(num+1 == k)&#123; for(int a = 0; a&lt;k; a++) &#123; stack.pop(); &#125; &#125; &#125; else&#123; stack.push(new Pair&lt;&gt;(s.charAt(i), 1)); &#125; &#125; else &#123; stack.push(new Pair&lt;&gt;(s.charAt(i), 1)); &#125; &#125; String ans = ""; while (!stack.isEmpty())&#123; char a = stack.peek().getKey(); ans = a + ans; stack.pop(); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>栈, Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)C++中struct和class的区别]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%BD%AC-C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[初学C++，对struct的用法感觉非常奇怪，和C中差别挺大。看到一篇博客写的挺好，转载一下。 原博客地址：C++中struct和class的区别 1）默认的继承访问权限。struct是public的，class是private的。 如果不知道什么是public继承，什么是private继承的，可以去查书，这里暂不讨论。 你可以写如下的代码： 123456789struct A&#123;char a;&#125;；struct B : A&#123;char b;&#125;； 这个时候B是public继承A的。如果都将上面的struct改成class，那么B是private继承A的。这就是默认的继承访问权限。所以我们在平时写类继承的时候，通常会这样写： 1struct B : public A 就是为了指明是public继承，而不是用默认的private继承。 当然，到底默认是public继承还是private继承，取决于子类而不是基类。我的意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。如下： 12345struct A&#123;&#125;；class B : A&#123;&#125;; //private继承struct C : B&#123;&#125;； //public继承 2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。 注意我上面的用词，我依 旧强调struct是一种数据结构的实现体，虽然它是可以像class一样的用。我依旧将struct里的变量叫数据，class内的变量叫成员，虽然它 们并无区别。其实，到底是用struct还是class，完全看个人的喜好，你可以将你程序里所有的class全部替换成struct，它依旧可以很正常 的运行。但我给出的最好建议，还是：当你觉得你要做的更像是一种数据结构的话，那么用struct，如果你要做的更像是一种对象的话，那么用class。 当然，我在这里还要强调一点的就是，对于访问控制，应该在程序里明确的指出，而不是依靠默认，这是一个良好的习惯，也让你的代码更具可读性。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swing的一些使用技巧]]></title>
    <url>%2F2019%2F09%2F25%2FSwing%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[记录一些Swing做GUI时候的一些技巧 窗体居中设置 1this.setLocationRelativeTo(null);//窗体居中显示 窗口自适应大小用Java代码先获得屏幕大小，然后在设置宽高。获得屏幕大小代码如下 123Dimension screen=Toolkit.getDefaultToolkit().getScreenSize();//得到屏幕的大小System.out.println (screen.getWidth());//输出屏幕的宽度System.out.println (screen.getHeight());//输出屏幕的高度 然后可以设置相应的bounds的比例 String使用的一个小经验下午在做判断两个字符串是否相等的时候，我用了==来进行判断，但一直会出错，当时一直不明白为什么。旁边的同学提醒我看idea的提示，让我改用equals()来判断，改完后就正确了。我就突然明白，两个字符串常量比较时候可以用==，因为他们判断时是判断他们是否指向同一个字符串。equals()是来判断两个字符串是否相等。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Swing, Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC学习笔记]]></title>
    <url>%2F2019%2F09%2F11%2FJDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录JDBC使用方法 什么是JDBCJDBC, Java Database Connecive, Java 数据库连接，是一组专门负责连接并操作数据库的标准，在整个JDBC中实际上大量的提供的是接口。针对于各个不同的数据库生产商 ，只要想使用JAVA 进行数据库的开发，则对这些标准有所支持。 JDBC操作步骤 加载数据库驱动程序 连接数据库，通过Connection 接口和 DriverManager 类完成 操作数据库，通过Statement、PreparedStatement、ResultSet 三个接口完成 关闭数据库 加载数据库我使用的是mysql连接，需要将mysql-connector-java-8.0.17.jar（我使用的是这个版本）这个包导入到项目之中。IDEA导入方法是，File -&gt; project structre -&gt; 左边选择Modules -&gt; 在这个包管理界面，点击右侧的➕ -&gt; 通过你的包的路径，选择这个jar包即可导入。 连接数据库123456789101112131415public class Demo &#123; public static void main(String[] args) &#123; try &#123; //加载驱动类 Class.forName("com.mysql.cj.jdbc.Driver"); //建立连接(连接对象内部其实包含了Socket对象，是一个远程连接。比较耗时！) //真正开发中，为了提高效率，都会使用连接池来管理连接对象。 Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC", "user","password"); System.out.println(con); &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 连接的时候遇到了几个问题。 1.报错：Loading class com.mysql.jdbc.Driver. This is deprecated. The new driver class is com.mysql.cj.jdb这个问题是因为高版本的驱动，连接class有所修改，forname()里面需要写“com.mysql.cj.jdbc.Driver” 而不是”com.mysql.jdbc.Driver” 2.报错：SQLException: The server time zone value ‘�й���׼ʱ��’ is unrecognized在配置datasource.url时出现了时区不一致的问题，在后面加上“?serverTimezone=UTC”即可 3.这里有两个异常操作，Java基础不是很好，暂时无法理解为什么这么写，先记住就好。 操作数据库Statement接口1234567891011121314151617181920public class Demo1 &#123; public static void main(String[] args) &#123; try &#123; //加载驱动类 Class.forName("com.mysql.cj.jdbc.Driver"); //建立连接 Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC", "user","password"); Statement stmt = con.createStatement(); String sql = " INSERT INTO tb_courses" + " (course_id,course_name,course_grade,course_info)" + " VALUES(2,'Network',3,'Computer Network');"; stmt.execute(sql); //SQL注入 &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 建立连接和前面时一致的。主要是中间的执行有所区别。 Statement是通过一个String来存储所要进行的sql操作，然后通过execute()方法来实现要进行的操作。存储的sql操作支持字符串拼接，可以将values的值拼接成一句sql语句。 这种可拼接的方法就带来了一个问题，叫做SQL注入。什么是SQL注入，也就是说，你在拼接的过程中是没有进行字符串检查的，万一在某个where语句后面拼接时，出现了判断结果与你预期的不一致，最后导致数据库内容出错，甚至删库的情况出现。视频讲解并不推荐这种方法。 PreparedStatement接口12345678910111213141516171819202122232425262728public class Demo2 &#123; public static void main(String[] args) &#123; try &#123; //加载驱动类 Class.forName("com.mysql.cj.jdbc.Driver"); //建立连接(连接对象内部其实包含了Socket对象，是一个远程连接。比较耗时！) Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC", "user","password"); String sql = "INSERT into tb_courses (course_name, course_grade) values(?,?)"; //?占位符 PreparedStatement ps = con.prepareCall(sql); //传参方法1// ps.setString(1, "JDBClearning");// ps.setFloat(2, 6.0f); //传参方法2 ps.setObject(1, "JDBC"); ps.setObject(2, 12); System.out.println("插入正在学习JDBC"); ps.execute(); &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; PreparedStatement作为Statement的子类，可以使用预编译，然后传参的方法，来实现sql语句。符号”?”作为占位符，为后面传参做准备。传参一共有两种方法可以使用。 一种是明确传参类型。比如传参是String类型，就用setString()方法来传参。第一个参数是表示位置信息，第二个是你要插入的数据。插入int就用setInt()方法，其他的类似。另一种是不明确传参类型。使用setObject()方法传所有参数。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当我在学MySQL时我到底在学什么]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%BD%93%E6%88%91%E5%9C%A8%E5%AD%A6MySQL%E6%97%B6%E6%88%91%E5%88%B0%E5%BA%95%E5%9C%A8%E5%AD%A6%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[一点MySQL学习感想 因为软工大作业项目的缘故，所以最近自己在学习如何使用MySQL数据库。学了有几天了，都是在学习命令行下的一些操作，给我的直接感受和当时使用navicat的感觉差不多，觉得好像就是把图形化界面使用命令行来表示了而已啊。找来一篇SQL语言教程，发现其实二者是互通的嘛。那么问题来了，当我在学MySQL时我到底在学什么呢？ 在知乎上翻看跟数据库有关的话题，如何回答这个问题心中慢慢有了眉目。回顾这几天的学习，说白了就是学习如何使用这种数据库，而数据库的主要功能无非就是存储和查询。学习数据库不是目的，它只是做开发时必须要用到的工具。对于当时做爬虫项目而言，数据库更可以是发掘数据中潜藏价值的仓库。 所以先学好怎么使用，有兴趣再去深入研究数据库原理等相关知识吧。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记]]></title>
    <url>%2F2019%2F09%2F07%2Fmysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MySQL学习记录 MySQL安装这个部分在暑假实习时候已经安装成功，就没有多花时间在这个上面。但为什么当时没有学习使用MySQL呢….当时用了navicat图形化管理，到后来不还是得学，哎…. MySQL数据库相关操作创建在MySQL中，使用create database语句创建数据库，语法格式如下： CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt; [[DEFAULT] CHARACTER SET &lt;字符集名&gt;] [[DEFAULT] COLLATE &lt;校对规则名&gt;];语法说明： IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。 [DEFAULT] CHARACTER SET：指定数据库的默认字符集。 [DEFAULT] COLLATE：指定字符集的默认校对规则。 实例1 输入create database test_db语句， 即可创建一个名为test_db的数据库 实例2 创建一个数据库，名为test_db_char，默认字符集为utf8，默认校对规则为utf8_general_ci mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_chinese_ci; Query OK, 1 row affected (0.03 sec)查看show databases语句，可以查看所有用户范围内的数据库该语句可以加上后缀like, 用于匹配数据库名称, 后面所借数据库名需用’ ‘括起来。 实例 show databases like &apos;test_db&apos; 完全匹配查找名为test_db的数据库 show databases like &apos;%test%&apos; 查找数据库名称中含有test的所有数据库 show databases like &apos;db%&apos; 查找数据库名称中以db开头的所有数据库 show databases like &apos;%db&apos; 查找数据库名称中以db结尾的所有数据库修改修改数据库语法格式为： ALTER DATABASE [数据库名] { [ DEFAULT ] CHARACTER SET &lt;字符集名&gt; | [ DEFAULT ] COLLATE &lt;校对规则名&gt;}查看数据库的定义声明：show create database 数据库名 实例 mysql&gt; CREATE DATABASE test_db -&gt; DEFAULT CHARACTER SET gb2312 -&gt; DEFAULT COLLATE gb2312_chinese_ci; mysql&gt; SHOW CREATE DATABASE test_db;删除语法格式： DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt; &lt;数据库名&gt;：指定要删除的数据库名。 IF EXISTS：用于防止当数据库不存在时发生错误。 DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。 选择语法格式: use &lt;数据库名&gt;如何查看当前使用的是哪个数据库?有三条语句可以实现。 select database(); show table; status; 引擎设置默认引擎： SET default_storage_engine=&lt; 存储引擎名 &gt;InnoDB 是系统的默认引擎，支持可靠的事务处理。通过上述语句修改后，默认引擎可以改变，但是MySQL重启后，默认引擎依然是InnoDB。 MySQL常见数据类型在MySQL中常见的数据类型如下所示: 1) 整数类型 包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型 FLOAT 和 DOUBLE，定点数类型 DECIMAL。 2) 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 3) 字符串类型 包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 4) 二进制类型 包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 具体数据类型的讲解可以看这儿MySQL常见数据类型 MySQL表相关操作创建其语法格式为： CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];其中，[表定义选项]的格式为： &lt;列名1&gt; &lt;类型1&gt; [,…] &lt;列名n&gt; &lt;类型n&gt;实例 船舰一个员工表，结构如下。 字段名称 数据类型 备注 id INT(ll) 员工编号 name VARCHAR(25) 员工名称 deptld INT(ll) 所在部门编号 salary FLOAT 工资 mysql&gt; USE test_db; Database changed mysql&gt; CREATE TABLE tb_emp1 -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt; ); Query OK, 0 rows affected (0.37 sec)使用show tables语句查看数据表是否创建成功 查看DESCRIBE/DESC 语句可以查看表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法规则如下： DESCRIBE &lt;表名&gt;; 或简写成： DESC &lt;表名&gt;;SHOW CREATE TABLE语句可以用来显示创建表时的CREATE TABLE语句，语法格式如下： SHOW CREATE TABLE &lt;表名&gt;\G；修改常用的语法格式如下： ALTER TABLE &lt;表名&gt; [修改选项] 修改选项的语法格式如下： { ADD COLUMN &lt;列名&gt; &lt;类型&gt; | CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt; | ALTER COLUMN &lt;列名&gt; { SET DEFAULT &lt;默认值&gt; | DROP DEFAULT } | MODIFY COLUMN &lt;列名&gt; &lt;类型&gt; | DROP COLUMN &lt;列名&gt; | RENAME TO &lt;新表名&gt; }添加字段ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]；实例：在第一列添加int类型字段col1 mysql&gt; ALTER TABLE tb_emp1 -&gt; ADD COLUMN col1 INT FIRST; Query OK, 0 rows affected (0.94 sec) Records: 0 Duplicates: 0 Warnings: 0若无 first 或 after，则默认在最后一行添加新字段 修改字段类型ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;删除字段ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；修改字段名称ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；新数据类型指的是修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。 修改表名ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；删除语法格式如下： DROP TABLE [IF EXISTS] &lt;表名&gt; [ , &lt;表名1&gt; , &lt;表名2&gt;] …语法说明如下：1.&lt;表名&gt;：被删除的表名。DROP TABLE 语句可以同时删除多个表，用户必须拥有该命令的权限。2.表被删除时，所有的表数据和表定义会被取消，所以使用本语句要小心。3.表被删除时，用户在该表上的权限并不会自动被删除。4.参数IF EXISTS用于在删除前判断删除的表是否存在，加上该参数后，在删除表的时候，如果表不存在，SQL 语句可以顺利执行，但会发出警告（warning）。 MySQL键约束键约束感觉就是给一些键增加特定的标识，作为这个表的某一种标识的体现。 键约束一共有主键、外键、唯一约束。 主键定义&amp;作用：“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 创建语法： &lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]实例：id int(11) primary key，此时id即成为这个表的主键。 在定义完所有列之后，指定主键的语法格式为： [CONSTRAINT &lt;约束名&gt;] PRIMARY KEY [字段名]实例：primary key(id),此时id即成为这个表的主键。 创建复合主键： PRIMARY KEY [字段1，字段2，…,字段n]实例：primary key(id, deptId),此时id和deptId即成为这个表的复合主键。 修改表时添加主键： ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);实例：ALTER TABLE tb_emp2 ADD PRIMARY KEY(id);，此时添加id成为这个表的主键。 外键定义&amp;作用：MySQL 外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。 创建语法： [CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]实例：CONSTRAINT fk_emp_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id) 修改表时添加外键： ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt; FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);实例： mysql&gt; ALTER TABLE tb_emp2 -&gt; ADD CONSTRAINT fk_tb_dept1 -&gt; FOREIGN KEY(deptId) -&gt; REFERENCES tb_dept1(id);删除外键： ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;实例: mysql&gt; ALTER TABLE tb_emp2 -&gt; DROP FOREIGN KEY fk_tb_dept1;唯一约束定义&amp;作用： MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 创建语法： &lt;字段名&gt; &lt;数据类型&gt; UNIQUE添加唯一约束： ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;);实例： mysql&gt; ALTER TABLE tb_dept1 -&gt; ADD CONSTRAINT unique_name UNIQUE(name); 删除唯一约束： ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;检查约束具体语法: CHECK &lt;表达式&gt; 修改表时添加约束： ALTER TABLE tb_emp7 ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;) 删除约束: ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;; 默认值设置：&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;; 非空约束设置: &lt;字段名&gt; &lt;数据类型&gt; NOT NULL; 选择数据selectselect语句语法： SELECT {* | &lt;字段列名&gt;} [ FROM &lt;表 1&gt;, &lt;表 2&gt;… [WHERE &lt;表达式&gt; [GROUP BY &lt;group by definition&gt; [HAVING &lt;expression&gt; [{&lt;operator&gt; &lt;expression&gt;}…]] [ORDER BY &lt;order by definition&gt;] [LIMIT[&lt;offset&gt;,] &lt;row count&gt;] ]查询表中全部内容，具体格式： SELECT * FROM 表名;查询指定字段，具体格式： SELECT &lt; 列名 &gt; FROM &lt; 表名 &gt;;去重消除重复的记录值，使用关键字distinct,具体语法: SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;;限制查询条数当只需要查询某几行内容时，需要用到关键字llimit，具体格式: &lt;LIMIT&gt; [&lt;位置偏移量&gt;,] &lt;行数&gt;实例1： SELECT * FROM tb_students_info LIMIT 4; 查询的就是1~4行的内容实例2： SELECT * FROM tb_students_info LIMIT 3,5; 查询的就是偏移3行，即4~8行的内容 排序具体格式： ORDER BY {&lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt;} [ASC|DESC]注:关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值。这两个关键字必须位于对应的列名、表达式、列的位置之后。 实例1： SELECT * FROM tb_students_info ORDER BY height;以height为升序排序 实例2： SELECT name,height FROM tb_student_info ORDER BY height DESC,name ASC;先以height为降序排序，然后以name为升序排序 条件查询筛选数据，具体格式： WHERE &lt;查询条件&gt; {&lt;判定运算1&gt;，&lt;判定运算2&gt;，…}判断语法如下:&lt;表达式1&gt;{=|&lt;|&lt;=|&gt;|&gt;=|&lt;=&gt;|&lt;&gt;|！=}&lt;表达式2&gt;&lt;表达式1&gt;[NOT]LIKE&lt;表达式2&gt;&lt;表达式1&gt;[NOT][REGEXP|RLIKE]&lt;表达式2&gt;&lt;表达式1&gt;[NOT]BETWEEN&lt;表达式2&gt;AND&lt;表达式3&gt;&lt;表达式1&gt;IS[NOT]NULL 插入数据]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++解题时的使用技巧]]></title>
    <url>%2F2019%2F09%2F03%2FC-%E8%A7%A3%E9%A2%98%E6%97%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[记录使用C++做CSP题目时用到的一些C中没用过的数据结构和算法 快排sort用法 头文件 #includesort函数可以有两个参数，也可以有三个参数： 排序数组起始位置 排序数组结束为止 排序的方法，确认是升序还是降序，默认缺省情况为升序排序 举例123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;int main()&#123; int a[20]=&#123;2,4,1,23,5,76,0,43,24,65&#125;,i; for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+20); for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; 注意sort函数第二个参数的范围。 下面主要举例讲解三个参数用来解决结构数组排序的问题。 在CSP 17-3-2排队问题中，我用了一个结构体来表示每个同学，其中包含他的学号和位置。我需要sort函数来对他们的位置进行排序，这个时候就需要用到带有三个参数的sort函数了。 结构体声明如下 1234typedef struct stu&#123; int id; int place;&#125;stu; 第三个参数函数声明如下 1234bool cmp(stu a, stu b)&#123; return a.place &lt; b.place;&#125; 因为我是要对他们的位置进行排序，而且是升序排序。通过修改return 的内容，可以实现对其他方面的排序以及修改排序的升降。 使用方法 1sort(array+1, array+1+n, cmp); 这样就能对结构数组其中的位置信息进行排序了。 栈和队列stack模板类定义在#include中定义示例代码：stack&lt;int&gt; s基本操作如下 操作 作用 s.push(x) 入栈 s.pop() 出栈，注意该操作只删除元素，不返回元素 s.top() 访问栈顶 s.empty() 栈是否为空，为空时返回true s.size() 访问栈的元素个数 queue模板类定义在#include中定义示例代码：queue&lt;int&gt; q基本操作如下 操作 作用 q.push(x) 入队 q.pop() 出队，弹出队列第一个元素，但不会返回其值 q.front() 访问队首元素，即第一个入队的 q.back() 访问队尾元素，即最后一个入队的 q.empty() 判断队空，若为空返回true q.size() 访问队元素个数 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;void stackFunction()&#123; stack&lt;int&gt; s; //入栈 s.push(1); s.push(2); s.push(3); //栈元素个数 cout&lt;&lt;"size of stack:"&lt;&lt;s.size()&lt;&lt;endl; //栈顶元素 cout&lt;&lt;"top of stack:"&lt;&lt;s.top()&lt;&lt;endl; //出栈 s.pop(); cout&lt;&lt;"after pop, top of stack is:"&lt;&lt;s.top()&lt;&lt;endl; //栈空 if(!s.empty()) cout&lt;&lt;"stack is not empty"&lt;&lt;endl; s.pop(); s.pop(); if(s.empty() ) cout&lt;&lt;"stack is empty now"&lt;&lt;endl;&#125;void queueFunction()&#123; queue&lt;int&gt; q; //入队 q.push(1); q.push(2); q.push(3); //队首元素 cout&lt;&lt;"front of queue:"&lt;&lt;q.front()&lt;&lt;endl; //队尾元素 cout&lt;&lt;"back of queue:"&lt;&lt;q.back()&lt;&lt;endl; //队长度 cout&lt;&lt;"size of queue:"&lt;&lt;q.size()&lt;&lt;endl; //出队 q.pop(); cout&lt;&lt;"after pop, front of queue is:"&lt;&lt;q.front()&lt;&lt;endl; //队空 if(!q.empty()) cout&lt;&lt;"queue is not empty"&lt;&lt;endl; q.pop(); q.pop(); if(q.empty() ) cout&lt;&lt;"queue is empty now"&lt;&lt;endl;&#125; int main()&#123; stackFunction(); cout&lt;&lt;endl; queueFunction(); cout&lt;&lt;endl; return 0;&#125; 结果 123456789101112size of stack:3top of stack:3after pop, top of stack is:2stack is not emptystack is empty nowfront of queue:1back of queue:3size of queue:3after pop, front of queue is:2queue is not emptyqueue is empty now]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++, CSP, 数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2019%2F09%2F01%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一直说是要学习Git，但总是一拖再拖。花了不到一天的时间，就把廖老师的Git教程学完了，受益匪浅，接下来可以在GitHub玩耍了233。顺便掌握了一些windows命令行操作，也很有用。 Git的第一步——创建版本库创建版本库 1234567891011$ mkdir &lt;repository name&gt;$ cd &lt;repository name&gt;创建一个目录$ git init （创建一个版本库）Initialized empty Git repository in &lt;当前路径&gt;.git/添加文件到Git仓库，分两步:$ git add &lt;file name&gt;$ git commit -m &lt;message&gt;可以先多次添加，最后一次提交 版本控制版本回退 123456789$ git log$ git log --pretty=oneline显示从最近到最远的提交日志$ git reset --hard HEAD~&lt;num&gt;(往前num个版本)$ git reset --hard &lt;commit id&gt;(前往对应的提交版本)修改HEAD指向的版本，HEAD指向的版本就是当前版本$ git reflog 查看命令历史，以便确定要回到未来的哪个版本 工作区和暂存区 1$ git status 常看状态 管理修改 12$git diff HEAD -- &lt;file name&gt;查看工作区和版本库里面最新版本的区别 撤销修改 12345$ git checkout -- file总之，就是让这个文件回到最近一次git commit或git add时的状态$ git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区 删除文件 1234情况一：将版本库中的删除$ git rm删掉，并且git commit情况二：误删除，需要恢复到版本库中$ git checkout -- test.txt 远程仓库添加远程仓库 12345678$ git remote add origin git@github.com:michaelliao/learngit.git连接远程仓库，github.com：后面接的是自己需要关联的仓库$ git push -u origin master将本地内容推到远程仓库第一次推送master分支的所有内容的命令行需要带 -u此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 从远程仓库克隆到本地 12$ git clone git@github.com:michaelliao/gitskills.git从远程仓库克隆到当前目录下，同样的，github.com：后面接的是自己需要克隆的仓库 分支管理创建与合并分支 1234567891011121314$ git checkout -b &lt;branch name&gt;创建并且切换到该 分支上$ git branch 查看当前分支情况，*对应的是当前所在的分支$ git checkout master切回到主分支$ git merge &lt;branch name&gt;将该分支合并到主分支上$ git branch -d &lt;branch name&gt;删除该分支 解决冲突 123当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log --graph命令可以看到分支合并图。 分支管理策略 1合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支 123修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 Feature分支 12开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作 (由于没有多人协作的项目经验，这一块看的并不是很明白，只能先把小结部分的内容接下来，以后有类似经验了再消化吸收) 123456查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 Rebase 12$git rebase（这个操作也是没有实践不大好理解啊，就先放这儿） 标签管理创建标签 123命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；命令git tag可以查看所有标签。 操作标签 1234命令git push origin &lt;tagname&gt;可以推送一个本地标签；命令git push origin --tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tagname&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。删除远程标签时，需要先删除本地标签。 配置别名这个看完了感觉还是很实用的，可以把一些比较长的命令行给简化拼写。我这刚刚入门，也不知道这么配置完了之后如果有问题，如何再修改回原来的配置，所以就先用着默认指令吧，以后再来修改。 windows下一些命令行操作12345ls dir 当前目录下的文件pwd chdir 显示当前所在的路径cat type &lt;file&gt; 显示文件内容rm del &lt;file&gt; 删除文件cd .. 返回上一级目录]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二暑假总结]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结一下大二暑假做的事儿，展望一下新学期 谈谈这个暑假放假的时间总是这么的快，感觉没做什么事情，假期又已经结束了。这个暑假不同于以前，自己决定在学校待一段时间，多学点东西再回家。虽然可能学的也不是很多，但至少还是有在学习的。所以想总结一下自己都在这个暑假干了些什么吧。 前期（托福课之前） 这段时间的话主要就是在做爬虫项目，学习了如何使用scrapy框架来进行爬虫。首先是通过豆瓣top250来进行练手，然后爬取了两个学术网站。爬取完后将数据存储到mysql数据库中。完成度的话，还有一些不足，比如mysql知识用navicat进行管理，并没有对数据库有更深的学习。而数据库这个方面在其他学习过程中发现应该是计算机知识很重要的一方面，大三还要多加学习。 还做的一些事就是在洛谷上刷题，学习计网，然后当时每天都有花时间背单词。平时锻炼也很多，晚上不是去打篮球就是去健身。这段时间过得还是挺满意的。 中期（托福课阶段） 这期间主要做的就两个事儿吧，1. 上托福课，2. 学习Java 托福课上完了，口语和听力的收获挺大，阅读的话主要还是靠自己来刷，写作其实当时老师讲的我觉得并没有特别清楚吧，这个后面练习的时候再去网上看看总结什么的。 Java主要是跟着菜鸟教程来学的。当时学到了Java包，基本上只是掌握了Java基础语法，后面的一些高级特性还没有深入学习。练习主要是靠LeetCode来刷题练习，算是练Java的使用，以及提高算法能力。Java的话大三上前段时间加紧学习，然后跟进羊哥推荐的开源项目的学习。 这段时间作息开始不是很规律，早上不早起，晚上早睡了睡不着，学习效率并没有很高。 后期（在家) 学习项目做了的就是刷tpo的阅读，做了有个3篇，得分都在21左右，阅读需要提高的地方还有很多。然后就是在leetcode上面刷题了，在探索中找到了“初级算法”，过一下里面的题目，提高一下自己的算法能力。 这一篇博客距离上一篇差不多有一个月了。前中期的学习还经常写一写博客来记录，后期在家就懒了不少，每天学习也不是很多吧。开学了就要开始继续努力，坚持写博客了。 展望一下大三开学了，加权单也贴到了墙上，看着大二的成绩，自己还是挺不满意的吧。跟大一比，退步了50名左右，真的就是在保研的边缘摇晃了。回想大二，感觉自己真的是很懈怠，课程内任务没有好好学，课程外也没有去学一些自己感兴趣的东西到现在了还啥都不会，就不具备一个开发者的思维模式以及能力。 这个暑假看了不少其他优秀的人是如何学习的，以及如何转变自己学习的思维模式，感觉还是受益良多的。仔细看了看大三的课程，课程相比大一大二，反而感觉课程少了不少，但都是专业课，所以要更加用心去学习，去实践。空余的很多时间要多拿来跑一下开源项目，提升一下自己的能力。 九月份任务 TPO刷题，每天2-3h的英语学习时间（不包括背单词的时间，单词每天也要背起来） 9.15号CSP考试，前两周就多花点时间在这个上面，一二题争取用时短，然后全对。第三题可能真的没法儿看懂，看不懂就算了，反正三四题争取一下。 学习一下git，以后也要用到的。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:数组题(1)]]></title>
    <url>%2F2019%2F08%2F01%2FLeetCode-%E6%95%B0%E7%BB%84%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录 26. 删除排序数组中的重复项题目描述(简单)给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 解题思路开始对原地修改有一些疑问, 后来发现直接进行覆盖即可, 就没什么难度了. 注意数组长度为0这种情况. 解题代码12345678910111213class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0) return 0; int i = 0; for(int j=1; j&lt;nums.length; j++)&#123; if(nums[j]!= nums[i])&#123; i ++; nums[i] = nums[j]; &#125; &#125; return (i+1); &#125;&#125; 27. 移除元素题目描述(简单)给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element 解题思路 排序 双指针 先对数组进行排序, 然后通过双指针找到等于val的第一个数, 和不等于val的第一个数, 然后进行覆盖 解题代码123456789101112131415161718192021class Solution &#123; public int removeElement(int[] nums, int val) &#123; if(nums.length == 0) return 0; Arrays.sort(nums); int front,tail; for(front=0; front&lt;nums.length; front++) &#123; if(nums[front] == val) break; &#125; for(tail = front; tail&lt;nums.length; tail++) &#123; if(nums[tail] != val) break; &#125; if(tail == nums.length) return front; else &#123; for(; tail&lt;nums.length; tail++) &#123; nums[front] = nums[tail]; front++; &#125; &#125; return front; &#125;&#125; 283. 移动零题目描述(简单)给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes 解题思路先把非0的数挪到前面, 并记录0的个数. 挪完后把后面的数全部置0即可 解题代码1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int front= 0; int counter = 0; //int [] nums = &#123;0,1,0,3,12&#125;; for(int i=0 ; i&lt;nums.length; i++) &#123; if(nums[i] != 0) &#123; nums[front] = nums[i]; front ++; &#125; else counter++; &#125; for(int i=front; i&lt;nums.length; i++) &#123; nums[i] = 0; &#125; &#125;&#125; 总结前三题刚上手LeetCode, 大部分题目对目前的我有点难度, 所以就从自己比较熟悉的数组开始尝试, 边学习Java的使用, 边提高算法能力. 前三题其实还是挺简单的, 主要是一个原地修改数组不另外开辟空间的要求, 最后用覆盖的方法解决了就好了. 11. 盛最多水的容器题目描述(中等)给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water 解题思路解法一 这个解法可以说相当好像到,就是暴力穷举, 用一个双重循环, 将所有的情况都枚举出来, 取其中的最大值即可. 想是很好想, 但是这个算法的效率却很低, 时间复杂度为O(n^2), 所以在这个题中, 我考虑的就是如何用别的算法来达到降低时间的这个目的. 我先用双重循环试了试它的时间, 最后结果为Java提交记录中的30%, 可见效率之低. 解法二 双指针解法:我是没想出来这个解法, 也是看了官方题解才明白的. 它的思路在于两条线段之间形成的区域面积受制于两条边中较短的边. 其次, 两条边距离越远, 面积越大. 通过放置两个指针, 一头一尾, 记录当前最大面积max. 然后移动较短的指针, 更新最大面积max, 直至头尾指针相遇. 只需要扫描一遍即可找到最大值, 所以时间复杂度为O(n). 这个方法看起来比较简单, 但是我在思考为什么这个算法正确的时候花了不少时间. 也看了很多讨论, 利用数学的论证这个方法的正确性, 最终也算是搞懂了. 思考 我发现对于一个问题啊, 我们特别喜欢用暴力穷举的方法来的到答案, 因为在你穷举的过程中看似吧每种可能都给考虑到了,是最周全的方法,结果也是最可靠的. 但是这种方法就会消耗更多的时间, 并且在问题规模大到一定程度后, 穷举在一定的时间内就是不可能完成的, 所以才会有算法的出现. 个人观点, 算法就是用一定的方法, 避免那些”不必要的”穷举, 只需要对部分内容进行操作, 就可以得到正确的结果的过程. 当然算法并不是说一拍脑子就想出来的, 可能想一个算法的过程会有aha moment, 但是想出来了之后都是要通过数学的证明来确定他的正确性的. 所以说数学这个工具也还是很重要的呢. 解题代码1234567891011public static int maxAreaBetter(int[] height) &#123; int max=0; for(int i=0, j=height.length-1; i&lt;j;) &#123; max = Math.max(max, Math.min(height[i], height[j])*(j-i)); if(height[i] &lt; height[j]) &#123; i++; &#125; else j--; &#125; return max; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark实验：HTTP]]></title>
    <url>%2F2019%2F07%2F21%2FWireshark%E5%AE%9E%E9%AA%8C%EF%BC%9AHTTP%2F</url>
    <content type="text"><![CDATA[掌握HTTP相关，实验内容比较简单，尝试学习中成长。 1.基本HTTP GET/response交互这个实验的本身很简单，就是让你访问一个仅含有一段简单的html代码的网站，然后根据http协议的请求头所包含的信息，来回答问题即可。但是在这个过程中我还遇到了挺多奇奇怪怪的问题。最开始操作不熟练，每次筛选后的到的纪录依然很多，多次尝试后，终于得到了和任务书介绍的类似界面。但是我发现自己的HTTP状态响应为304 Not Modified, 和任务书中的200 OK不同，就很奇怪为什么。当时在下面详情里面看到了If Modified Since, 以及Accept Language。因为不是很明白为什么会出现这种情况，于是就先跳过实验一，看实验二去了。看了实验二才知道，304响应是因为我之前就访问过这个界面，然后浏览器产生了这个网页的缓存，304是说这个界面没有改变的意思。 2.HTTP条件Get/response交互实验二中熟悉操作之后就得到了对应的结果。在检查If-Modified-Since时，发现状态304中出现了这个标识，而且在状态200中，对应的是Last Modified,而且二者时间是一致的。探究If-Modified-Since是何物，网上给到的结果是 意思是我们在请求时会发送给服务器上次它修改这个文件最后一次时间，如果服务器发现仍然没有修改这个文件，就会返回304文件为改变的信息，调用本地caceh缓存，如果改变就会重新得到。 3.检索长文件实验三顺利执行，结果如下图数据信息包含在HTTP响应体里面。由于html文本过长，所以TCP共分了4个帧来存放这些信息，分组情况如下图 4.具有嵌入对象的HTML文档实验四捕获结果如下一共有三个HTTP GET请求，访问的IP地址都是128.119.245.12，按顺序得到了三个内容，分别是：html文件、pearson的图片、以及教材第五版的封面图，由于请求的时间不同，所以判断应该不是并行获得，而是按顺序请求获得。 5.HTTP认证实验五结果如下图最开始登录之后得到的界面是404 Not Found，感觉很奇怪啊，这不应该啊。后来检查了一下仓库中的URL，发现是给的URL打漏了一个”-“，打开正确的URL即可得到正确的结果界面。然后就在issue里面提交了这个问题，觉得Github还是很有意思啊。任务中让我们尝试base64加密方式，在wireshark中会自动解码出来，具体结果如下所示 Authorization: Basic d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=\r\n Credentials: wireshark-students:network上面是加密前，下面是解密后的结果。可见我们的密码并不是很安全，需要别的措施来防止别人窃取。 6.实验收获这个实验还是蛮简单的，具体步骤不知道怎么做或者是不知道要得到什么结果，参照一下Github上的pdf也就很容易解决。相比较第一个Wireshark，这个更加有实际操作的感觉，也锻炼了使用这个工具，继续努力~]]></content>
      <categories>
        <category>实操纪录</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codesheep笔记:为什么推荐Java而不是C++]]></title>
    <url>%2F2019%2F07%2F19%2Fcodesheep%E7%AC%94%E8%AE%B0-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90java%E8%80%8C%E4%B8%8D%E6%98%AFc%2F</url>
    <content type="text"><![CDATA[java学过很多次，但是每次都没有坚持学下去，觉得没有什么动力，看了羊哥的这个视频，觉得更有必要好好学习Java了。 1.目前的市场情况 互联网服务背后主流驱动技术就是Java，应用广泛 招聘岗位远比其他语言大的多 羊哥的实际感受：C/C++项目经历没有什么连续性，而Java则不一样。虽然业务不同，但编程经验都是一样的，具有较强的连续性。而且随着经验的丰富，可以转换到高级的方向很多 总结：市场表现来看，Java是最好的语言 2.内因：Java本身也很争气Java自身强大与优雅之处： 面向对象。Java是一个纯面向对象的语言，本身就是面向企业开发、大系统来设计的 静态语言。静态语言就有编译过程，在编译过程中可以报错，确保系统安全；其次，静态语言的速度会比动态语言快很多 Java两个最强的技术特性： 跨平台特性。 自动内存管理。 3.Java语言的应用场景和生态J2EE生态丰富完整，拥有很多可靠的开源软件 4.Java新的生命力的注入版本更新迭代快，更多高性能属性不断加入 5.怎么学 Java的基础语法 企业级开发框架：SSM、Spring Boot。数据库学习 书籍推荐]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>codesheep笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络（自顶向下方法）》学习笔记（持续更新）]]></title>
    <url>%2F2019%2F07%2F18%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面暑期实习做网络爬虫相关的事情，对计网有了一定的初步认识，感觉蛮有趣的，想到下学期也要学习计网，所以就准备提前学习了。买了课本，也在MOOC上学习，用博客来记录学习笔记。 实验资料：wireshark实验 1. 计算机网络和因特网1.1 什么是因特网网络：许多计算机连接在一起。 互联网（internet）：许多网络连接在一起。 因特网（Internet）：全球最大的互联网。 ISP（Internet Service Provider）：网络运营商（如移动，联通，电信等）。 端系统、分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接受和发送。TCP(Transmission Control Protocol, 传输控制协议)和IP(Internet Protocol, 网际协议)是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接受的分组格式。因特网的主要协议统称TCP/IP协议。 套接字接口（socket interface）:由与因特网相连的端系统提供，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序员交付数据的方式。因特网套接字接口是一套发送程序必须遵循的规则集合。可以与寄信、送信、收信的流程来类比。 协议：定义了在两个或多个通信实体之间交换的报文和顺序。以及报文发送和/或接受一条报文或其他事件所采取的动作。类比人类之间的交谈。 1.2 网络边缘端系统：与因特网相连的计算机和其他设备的称呼，因为位于因特网的边缘而得名。组成：包括了桌面计算机、服务器和移动计算机。端系统也统称为主机。 以太网（Ethernet）是一种计算机局域网技术，是目前应用最普遍的局域网技术。 1.3 网络核心为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。（交换机主要有两类：路由器和链路层交换机）。多数分组交换机在链路的输入端使用存储转发传输机制。 输出缓存（也称输出队列）：用于存储路由器准备发往那条链路的分组。排队时延：到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。分组丢失（丢包）：一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满，到达的分组或已经排队的分组之一将被丢弃。 1.4 分组交换网中的时延、丢包和吞吐量2. 应用层2.1 应用层协议原理2.2 Web和HTTP2.3 因特网中的电子邮件2.4 DNS:因特网的目录服务2.4.1 DNS提供的服务识别主机有两种方式，通过主机名或者IP地址，需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统DNS（Domain Name System）的主要任务。DNS是： 一个由分层的DNS服务器实现的分布式数据库。 一个使得主机能够查询分布式数据库的应用层协议。提供的其他重要服务： 主机别名。存在别名时，原始名被称为规范主机名。 邮件服务器别名。 负载分配。 2.4.2 工作机理工作过程应用程序需要主机名转换成IP地址 → 调用DNS客户算 → 用户主机上的DNS收到请求后，向网络中发送一个DNS查询报文（请求、回答报文使用UDP数据包经端口53发送） → 收到一个提供所希望映射的DNS回答报文 → 映射结果被传递到调用DNS的应用程序。 最开始的DNS的简单设计是一个DNS服务器，集中式设计存在如下问题：单点故障、通信容量、远距离的集中式数据库、维护。因此DNS采用了分布式的设计方案。 分布式、层次数据库大致讲，共有3种类型的DNS服务器： 根DNS服务器。提供TLD服务器的IP地址。 顶级域（Top-Level Domain, TLD）(DNS)服务器。顶级域（com, org, net, edu, gov）和所有国家的顶级域(uk, fr, ca, jp)都有TLD服务器。提供全为DNS服务器的IP地址。 权威DNS服务器。层次之外还有一种重要的DNS服务器：本地DNS服务器。每个ISP都有一台本地DNS服务器。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。查询方式：理论上讲，查询可以是递归查询也可以是迭代查询。实践中采取如下模式：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。 DNS缓存目的：为了改善时延性能并减少在因特网上到处传输的DNS报文数量。原理：在一个请求链中，当某DNS服务器接收到一个DNS回答时，它能够将映射缓存在本地储存器中。如果在DNS服务器中缓存了一台主机名/IP地址对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址，即使它不是该主机的权威服务器。缓存的信息通常保留两天。 2.4.3 记录和报文pass P2P文件分发套接字编程：生成网络应用本节目的：考察研发一个CS服务器应用程序中的关键问题，将实现一个非常简单的CS服务器应用程序代码 .1 UDP套接字 术语缩写]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七月上半月总结]]></title>
    <url>%2F2019%2F07%2F18%2F%E4%B8%83%E6%9C%88%E4%B8%8A%E5%8D%8A%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[暑假过的时间是真的快啊,感觉还没做些什么七月就已经过半了，想着还是有必要纪录一下这段时间都干了些什么，也算一种成长记录与自我总结反思。 七月上半月我都做了些什么： 暑期实习 学习了scapry框架下爬虫的使用 对论文期刊进行了爬虫实践，将论文信息按照学长给的表格给爬取了下来。 将论文内容存储到mysql数据库。 英语学习 每日背单词 进行了几天的听力训练 计算机网络学习 跟着中国大学mooc上的课程学习。 看《计算机网络（自顶向下方法）》 每日运动 基本上每天都会去健身房或者去球场打球，如果不是很想去，也会在寝室进行一些健身运动。 不足之处： 说好的每天规律作息，其实并没有很好地去完成。每天晚上不是很睡得着，白天就起不来，经常睡到九十点，一个上午就浪费掉了。 爬虫项目目前进度挺慢的，不是很上心。 计网的学习又是受会出现三天打鱼两天晒网的情况，不是很好。 有一段时间没有去洛谷和CSP打代码咯。 评价一下自己上半个月，我觉得基本满意，还有不足需要继续努力。通过做爬虫的实习，开始对计网感兴趣，并自主去学习，我觉得还是很有意思的。健身运动也没停，body building做的还不错，希望能更壮一点。下半个月要开始上托福课了，作息应该会比较规律，要继续努力，越努力越优秀。 下个月要做的事： 抓紧实习项目的进展，不懂得多自我学习解决，实在不会再去麻烦学长。 认真上托福课，不能让钱白花，多自学。 英语背单词不要中断，养成一种习惯。 培养写博客的习惯。搭建自己的博客不是目的，写博客才是最终的需要去做的，坚持学习，坚持输出。 抽时间去oj做做题鸭。 健身再壮一点。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客——hexo搭建以及美化]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面因为刚好想总结一下这段时间的学习到的东西，正在考虑注册个csdn还是简书，看到了羊哥的视频，就心血来潮自己搭了个独立博客，还是很有趣的，希望以后能多多学习多多积累。 搭建过程首先是根据羊哥评论里面一个小伙伴博客的帖子，把前期安装给解决了。然后跟着羊哥（codesheep）的视频把博客部署到了github上去。最后看知乎的一个帖子来美化我的博客。怎么说呢，现在markdown格式什么的也是第一次接触，都挺不熟练的，但是总要迈出第一步的嘛。这一篇就记录一下搭建的过程，有些东西还想补充，但是markdown语法不会，不知道该怎么添加，就以后再加。这几天就把这段时间爬虫的学习经历总结一下，发一篇博客。 图床搭建博客中的图片插入还会一个问题，需要使用到图床，这里采用的是七牛云图床，具体搭建方法参考了这个博客。 刚才还发现markdown格式自己疏忽的地方，在添加“博客”这个链接的时候，通过中括号+小括号，发现并没有像之前的链接会变成蓝色，检查之后，原来是使用了中文括号的缘故。这种问题在编译器里面看都不是很容易察觉，更不用说在这个markdownpad中了，还是要注意一下。 博客发表之前每次发布、修改，都要通过下面三个指令来实现： hexo clean hexo g hexo d之前感觉每次都这么输挺麻烦的，不过好像发布就得这个样子，后期再研究研究。发布之前可以先通过本地的localhost来看一下博客格式是否与自己想法一致，通过输入下面的指令来开启本地hexo服务。 hexo s不过这种方式默认使用的是4000端口，我的本地4000端口好像被占用了，解决这个有两种方法，一个是干掉本地占用4000端口的服务，让hexo来使用。另一种方式就是将hexo服务换一个端口来实现，这里我使用的是5000端口，指令如下。 hexo s -p 5000美化进阶之前就是换了个Next主题，虽然说挺够用的，还是挺简陋的，不够酷，所以找了个教程来配置next主题，先码住，之后再修改。Hexo博客第三方主题next进阶教程一个next基础配置帖子,很受用。 博客再更我突然明白了为什么有现成的博客网站大家不用，而是选择自己搭建博客这种比较麻烦的方式，因为可以自定义。有的人喜欢现成的东西，用起来简单省心，虽然可能有一些自己想有但是没有的功能，或者是用起来不舒服的地方。有的人喜欢自己来定义，虽然比较麻烦，比较操心，但出了什么问题都可以通过自己来解决，就很合自己的心意。就像《食戟之灵》里面的central和幸平他们的争斗，也是如此，为了自由而战。也明白了为什么UDP协议既然是不安全的，都用TCP协议不就好了，因为UDP轻量，方便自己去定制。 markdown的一些语法markdown让文字居中和带颜色]]></content>
  </entry>
</search>
