<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM整合踩坑]]></title>
    <url>%2F2020%2F05%2F10%2FSSM%E6%95%B4%E5%90%88%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[错误列表 跳转出现错误 修改失败 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记]]></title>
    <url>%2F2020%2F05%2F07%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[跟着官方文档学习Spring IOC容器依赖注入 构造器注入 set方式注入⭐ 依赖：bean对象的创建依赖于容器 注入：bean中的所有属性，由容器注入 拓展方式注入 p命名 c命名 注意点⚠️：需要去官网引入xml约束 bean的作用域官方介绍 Scope Description singleton 单例模式 (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. 单例模式（Spring默认实现） 原型模式 每次从容器中get时，都会产生一个新的对象 其余几个在web开发中使用 bean的自动装配 自动装配是spring满足bean依赖的一种实现 Spring会在上下文中寻找，并且给bean装配属性 三种装配方式： xml中配置 在java中显式配置 隐式自动装配⭐ autowire: byName byType 小结： byName时需要保证所用bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致 byType时需要保证所用bean的type唯一，并且这个bean需要和自动注入的属性类型一致 使用注解 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” 使用注解的xml支持 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired：自动装配，通过类型，名字 如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value = “xxx”) @Nullable：字段标记了这个注解，说明这个字段可以为null @Resource：自动装配，通过名字，类型 @Autowired和@Resource的区别： 同 都是用来自动装配的，都可以放在属性字段上 异 @Autowired通过bytype方式实现，而且必须要求该对象存在 @Resource默认通过byname方式实现，如果找不到名字，则通过bytype方式实现，如果都找不到，则会报错 使用注解开发 bean 属性如何注入 衍生的注解 @Component有几个衍生注解，在web开发中，会采用mvc三层架构 dao【@Repository】 service【@Service】 controller【@Controller】 这四个注解功能都是一样的，都代表着将某个类注册到Spring中，装配Bean 自动装配 作用域 @Component：组件，说明该类被Spring管理了 使用Java的方式配置SpringSpring xml --&gt; Java 纯Java配置方式，在Springboot中随处可见 10、代理模式为什么要学习代理模式？因为这就是Spring AOP的底层实现 代理模式的分类： 静态代理 动态代理 代理模式示意图 10.1、静态代理角色分析： 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实觉得，代理真实角色后，我们一般会做一些附属操作 客户：访问代理角色的对象 代码步骤： 接口 真实角色 代理角色 客户端访问 代理模式的好处： 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展时，方便集中管理 缺点： 一个真实角色，就会产生一个代理角色；代码量会翻倍，开发效率降低 10.2、加深理解 10.3、动态代理 动态代理和静态代理角色一样 动态代理的代理类时动态生成的，不是我们直接写好的 动态代理分为两大类： 基于接口的动态代理—JDK动态代理 基于类的动态代理—cglib java字节码实现；javasist 需要了解两个类：proxy:代理，InvocationHandler:调用处理程序 动态代理的好处： （静态代理的好处全都有） 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要是实现了同一个接口即可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习笔记]]></title>
    <url>%2F2020%2F05%2F04%2FSpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[SpringBoot学习过程整理的笔记～ 第一个spring boot程序创建项目： 官网生成 idea创建 自动装配原理初探 Spring没看，直接看这一块太苦难了😩 索性先跳了 Spring boot配置Springboot推荐使用yaml进行配置 yaml也可以对实体类进行赋值 Web开发需要结局的问题： 导入静态资源 创建首页 模版引擎Thymeleaf 装配扩展SpringMVC CRUD 拦截器 国际化 静态资源 Springboot下，可以用以下方式访问静态资源 Webjars localhost:8080/webjars public, static, resources, /** localhost:8080/ 优先级：resources &gt; static(默认) &gt; public document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记]]></title>
    <url>%2F2020%2F04%2F24%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录学习MyBatis时的一些笔记 1 简介1.1 什么是MyBatis MyBatis是一款优秀的持久层框架 它支持定制化SQL、存储过程以及高级映射 MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取届国际 MyBatis可以使用简单的XML或注解来配置和映射原声类型、借口和Java的POJO为数据库中的记录 MyBatis本是apache的一个开源项目iBatis,最后移植到了google code, 并改名为MyBatis maven仓库 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 1.2 持久化数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(jdbc)、io文件持久化 为什么需要持久化？ 有一些对象，不能让其丢失 内存太贵 1.3 持久层Dao层、Service层、Controller层…… 完成持久化工作的代码块 层界限明显 1.4 为什么需要MyBatis? 简单易学 灵活 sql和代码的分离，提高了可维护性 提供映射标签，支持对象与数据库的orm子段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql 2 第一个MyBatis程序2.1 搭建环境创建数据库 1234567891011121314CREATE DATABASE `mybatis`;USE `mybatis`;CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `passwrod` VARCHAR(30) DEFAULT NULL) ENGINE = INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`, `name`, `password`) VALUES(1, "德玛西亚", "demacia"),(2, "张三", "123"),(3, "李四", "abcd") 新建项目： 新建一个普通的maven项目 倒入maven依赖 2.2 创建模块 编写mybatis核心配置 3 CRUD3.1 namespacenamespace中的包名要和接口中的包名一致 3.2 select id: 就是对应的namespace中的方法名 resultType: sql语句执行的返回值 parameterType:参数类型 编写接口 12//get user by idUser getUserById(int id); 编写对应mapper中的sql语句 123&lt;select id="getUserById" parameterType="int" resultType="com.promethuesYuan.pojo.User"&gt; select * from user where id = #{id}&lt;/select&gt; 测试 12345678910@Testpublic void getUserByIdTest(){ try (SqlSession sqlSession = MyBatisUtils.getSqlSession()){ UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User userById = userMapper.getUserById(4); System.out.println(userById); }} 3.3 insert123&lt;insert id="addUser" parameterType="com.promethuesYuan.pojo.User"&gt; insert into user (id, name, password) values (#{id}, #{name}, #{password})&lt;/insert&gt; 3.4 update123&lt;insert id="updateUser" parameterType="com.promethuesYuan.pojo.User"&gt; update user set name=#{name}, password=#{password} where id=#{id}&lt;/insert&gt; 3.5 delete123&lt;delete id="deleteUser" parameterType="com.promethuesYuan.pojo.User"&gt; delete from user where id=#{id}&lt;/delete&gt; ⚠️：增删改需要提交事物 3.6 万能的map假设，我们的实体类或者数据库中的表，字段或者参数过多，我们应当考虑使用map！ 12//insert one user vid mapint addUserByMap(Map&lt;String, Object&gt; map); 123&lt;insert id="addUserByMap" parameterType="map"&gt; insert into user (id, name, password) values (#{mapid}, #{mapname}, #{mappassword})&lt;/insert&gt; 12345678910111213public void addUserByMapTest(){ try (SqlSession sqlSession = MyBatisUtils.getSqlSession()){ UserMapper userMapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("mapid", 5); map.put("mapname", "xiao 5"); map.put("mappassword", "5555"); userMapper.addUserByMap(map); sqlSession.commit(); }} map传递参数，直接在sql中取出key即可 多个参数用map,或者注解 4 配置解析4.1 核心配置文件 Mybatis-config.xml 123456789101112properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 4.2 环境配置（environments）MyBatis 可以配置成适应多种环境，。 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 MyBatis默认的事务管理器就是JDBC, 连接池：POOLED 4.3 属性（properties）可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 编写一个配置文件 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCusername=rootpassword=11235813 核心配置文件中引入 12345678910111213&lt;properties resource="db.properties"&gt;&lt;/properties&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="${driver}"/&gt; &lt;property name="url" value="${url}"/&gt; &lt;property name="username" value="${username}"/&gt; &lt;property name="password" value="${password}"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 可以直接引入外部文件 可以在其中增加一些属性 如果两个文件中有同名属性，优先使用外部配置文件的 4.4 类型别名（typeAliases）类型别名可为 Java 类型设置一个缩写名字，意在降低冗余的全限定类名书写 123&lt;typeAliases&gt; &lt;typeAlias type="com.promethuesYuan.pojo.User" alias="User"/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，mybatis会在该包下搜索需要的java bean。扫描实体类的包，他的默认别名为该类类名首字母小写 123&lt;typeAliases&gt; &lt;package name="com.promethuesYuan.pojo"/&gt;&lt;/typeAliases&gt; 如果实体类比较少，使用第一种。十分多时，建议使用第二种。如果需要改，可以在实体类上加注释 12@Alias("hello")public class User { 4.5 设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 4.6 映射器（mappers）注册绑定我们的mapper文件 123456&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource="org/mybatis/builder/AuthorMapper.xml"/&gt; &lt;mapper resource="org/mybatis/builder/BlogMapper.xml"/&gt; &lt;mapper resource="org/mybatis/builder/PostMapper.xml"/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class="org.mybatis.builder.AuthorMapper"/&gt; &lt;mapper class="org.mybatis.builder.BlogMapper"/&gt; &lt;mapper class="org.mybatis.builder.PostMapper"/&gt;&lt;/mappers&gt; 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name="org.mybatis.builder"/&gt;&lt;/mappers&gt; 后面两种方法的注意点： 接口和他的mapper文件必须同名 接口和他的mapper文件必须在同一个包下 4.7 作用域（Scope）和生命周期 作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder: 一旦创建了SqlSessionFactory，就不再需要他了 局部变量 SqlSessionFactory: 说白了就是可以想象为：数据库连接池 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例 因此SqlSessionFactory的最佳作用域是应用作用域 最简单的就是使用单例模式或者静态单例模式 SqlSession： 连接到数据库连接池的一个请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭 每一个Mapper，就代表一个具体的业务 5 解决属性名和字段名不一致的问题解决方法： 起别名 结果集映射resultMap 元素是 MyBatis 中最重要最强大的元素。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 12345&lt;resultMap id="userResultMap" type="User"&gt; &lt;id property="id" column="user_id" /&gt; &lt;result property="username" column="user_name"/&gt; &lt;result property="password" column="hashed_password"/&gt;&lt;/resultMap&gt; 然后在引用它的语句中设置 resultMap 属性就行了（注意我们去掉了 resultType 属性）。比如: 12345&lt;select id="selectUsers" resultMap="userResultMap"&gt; select user_id, user_name, hashed_password from some_table where id = #{id}&lt;/select&gt; 6 日志6.1 日志工厂如果一个数据库操作出现了异常，我们需要排错。日志就是最好的助手 设置名 描述 有效值 默认值 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 具体设置： 123&lt;settings&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt;&lt;/settings&gt; 6.2 Log4j什么事log4j: Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 倒入包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j配置文件 Mybatis-config中配置使用 123&lt;settings&gt; &lt;setting name="logImpl" value="LOG4J"/&gt;&lt;/settings&gt; 程序中使用log4j输出 测试，查看日志文件 7 分页实现原始方法：使用limit进行分页 8 注解开发8.1 面向接口编程8.2 使用注解9 Lombok Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. 使用方法： idea中安装lombok插件 倒入maven仓库 在实体类上加注解 123456789101112131415161718@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows@val@var 说明： 123456@Data: 无参构造器，getter, setter, tostring, hashcode, equals@AllArgsConstructor:有参构造器@RequiredArgsConstructor@NoArgsConstructor：无参构造器@ToString@EqualsAndHashCode 10.多对一处理11.一对多处理12.动态SQL13.缓存什么是缓存一级缓存二级缓存 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Maven]]></title>
    <url>%2F2020%2F04%2F23%2F%E5%88%9D%E8%AF%86Maven%2F</url>
    <content type="text"><![CDATA[Maven介绍以及安装，换源 什么是MavenMaven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。 Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 环境配置 项目 要求 JDK Maven 3.3 要求 JDK 1.7 或以上 Maven 3.2 要求 JDK 1.6 或以上 Maven 3.0/3.1 要求 JDK 1.5 或以上 Mac通过brew安装Maven 首先brew search maven得到以下结果： 12345==&gt; Formulaemaven maven-shell maven@3.3maven-completion maven@3.2 maven@3.5 ✔==&gt; Casksmavensmate homebrew/cask-fonts/font-maven-pro 可以选择直接下载maven，这个是最新版的，我下的是3.5这个版本。 下载命令：brew install maven或者brew install maven@你想要的版本 下载完成之后，我们还需要配置maven的环境变量。zsh环境变量在~/.zshrc中，我们加入下面的内容。（⚠️：每个操作系统环境变量可能不一样，以自己本机进行设置） 12export M2_HOME=/usr/local/Cellar/maven@3.5/3.5.4_1/libexecexport PATH=$PATH:$M2_HOME/bin 添加后使文件生效：source ~/.zshrc 测试是否安装成功 利用mvn -v命令进行检测，得到下面的结果基本就没问题啦～ 12345Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: /usr/local/Cellar/maven@3.5/3.5.4_1/libexecJava version: 11.0.2, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/openjdk-11.0.2.jdk/Contents/HomeDefault locale: zh_CN_#Hans, platform encoding: UTF-8OS name: "mac os x", version: "10.15.3", arch: "x86_64", family: "mac" 阿里镜像Maven仓库默认的是国外的仓库，下载速度感人，切换成国内的镜像下载就很快了，这里我换成了阿里的镜像源。 进入你刚下载maven的目录，然后打开conf目录下的settings.xml，找到mirrors健值对，在中间加上： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm中文报错]]></title>
    <url>%2F2020%2F04%2F22%2FPycharm%E4%B8%AD%E6%96%87%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[解决Pycharm中中文注释报错的问题 尝试用python来生成数据库实验的数据源时，运行程序出现了以下错误 1SyntaxError: Non-ASCII character '\xe6' in file test/t.py on line 19, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 从错误信息中大概能猜测出跟字符集有关，应该是程序中有中文的缘故，不知道为什么注释中有中文也会报错= = 解决方法是在当前文件的文件头加上# -*- coding:utf8 -*- 表明使用utf-8的字符集，即可正常运行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb总结]]></title>
    <url>%2F2020%2F04%2F21%2FJavaWeb%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[书城项目错误记录]]></title>
    <url>%2F2020%2F04%2F15%2F%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[跟着尚硅谷书城项目学习，完成的时候遇到了一些问题，本文用于记录问题以及解决方法 问题1:数据库连接有问题JdbcUtils实现后，对该模块进行测试，看能否与数据库正常连接。此时出现了以下的错误： 报错说:Client does not support authentic protocal requested by server.在这篇文章找到了解决方法。 出现该报错的主要原因是mysql服务器要求的认证插件版本与客户端不一致造成的。在mysql 8.0的版本中，默认的认证插件为caching_sha2_password，必须使用支持该插件的客户端版本。 那么如何解决呢？ 通过命令行进入mysql终端后，输入以下命令： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你想设置的MySQL登录密码'; FLUSH PRIVILEGES 运行结果如图所示： 修改后再对数据库连接进行测试，发现连接成功。 问题2:数据库字符集出错在问题1解决后，测试时还出现了这个问题： 依然是mysql的连接问题，由问题提示可以发现，这个问题应该是和字符集有关，查阅资料后，发现在连接的配置文件中，在url后面加上?useUnicode=true&amp;characterEncoding=utf8就可以解决问题。 添加之后，测试时可以正常连接。 问题3:注册界面无法正常跳转跟着老师的讲解写代码，在写注册界面的代码逻辑时，配置好html标签内容以及servlet内容后，我发现实现结果和老师讲解不太一样。我点击注册后，url确实编程了servlet的路径，但是没有页面。 在仔细看了好几遍代码，确认无误后，还是没找到问题。最终重新部署了一下服务器，就正常了…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上安装Tomcat]]></title>
    <url>%2F2020%2F04%2F15%2FMac%E4%B8%8A%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"><![CDATA[在Mac上安装Tomcat步骤记录 1.安装Tomcat先到官网上下载Tomcat：https://tomcat.apache.org/download-80.cgi。这里我下载的版本是Tomcat 8.5，可以根据自己的需要选择版本进行下载。 解压Tomcat文件，可以重新命名为AppacheTomcat，方便查找，最后放入/Library（系统资源库）文件夹中。该目录为隐藏文件夹，可以通过shift+command+g来进行跳转。 2.终端操作进入刚才保存Tomcat的路径下，该目录下有以下文件： 我们输入cd ./bin,进入bin目录 进入后，需要修改文件的访问权限，在终端输入sudo chmod 755 *.sh，输完回车。此时需要输入密码，输入密码后回车。 修改完成后，就可以启动Tomcat了。终端输入sudo sh ./startup.sh，终端会输出以下内容： 从图中可以看出，Tomcat已经启动成功。 打开浏览器，网址框中输入：localhost:8080， 会出现以下画面 想要关闭Tomcat的运行，在该目录下输入sh ./shutdown.sh,回车即可关闭 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 学习笔记]]></title>
    <url>%2F2020%2F04%2F11%2FJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录学习JS时的一些知识点 输出JavaScript 能够以不同方式“显示”数据： 使用 window.alert() 写入警告框 使用 document.write() 写入 HTML 输出 使用 innerHTML 写入 HTML 元素 使用 console.log() 写入浏览器控制台 使用 innerHTML如需访问 HTML 元素，JavaScript 可使用 document.getElementById(id) 方法。 id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容：document.getElementById("demo").innerHTML = 5 + 6; 使用 document.write()出于测试目的，使用 document.write() 比较方便：document.write(5 + 6); 注意：在 HTML 文档完全加载后使用 document.write() 将删除所有已有的 HTML 使用 window.alert()您能够使用警告框来显示数据：window.alert(5 + 6); 使用 console.log()在浏览器中，您可使用 console.log() 方法来显示数据。 请通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。console.log(5 + 6); 语句 关键词 描述 break 终止 switch 或循环。 continue 跳出循环并在顶端开始。 debugger 停止执行 JavaScript，并调用调试函数（如果可用）。 do … while 执行语句块，并在条件为真时重复代码块。 for 标记需被执行的语句块，只要条件为真。 function 声明函数。 if … else 标记需被执行的语句块，根据某个条件。 return 退出函数。 switch 标记需被执行的语句块，根据不同的情况。 try … catch 对语句块实现错误处理。 var 声明变量。 语法 混合值（字面量） 数值 字符串（单双引号） 变量 val 运算符 表达式 注释 同Java 特殊运算 12var x = "8" + 3 + 5; //结果为835var y = 3 + 5 + "8"; //结果为88 运算符基本与Java相同，几个不同的列举一下 运算符 描述 == 等于 === 等值等型 != 不相等 !== 不等值或不等型 typeof 返回变量的类型。 instanceof 返回 true，如果对象是对象类型的实例。 ** 幂 数据类型字符串值，数值，布尔值，数组，对象。 JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等： 1234var length = 7; // 数字var lastName = "Gates"; // 字符串var cars = ["Porsche", "Volvo", "BMW"]; // 数组var x = {firstName:"Bill", lastName:"Gates"}; // 对象 JavaScript 从左向右计算表达式。不同的次序会产生不同的结果：这个之前有记哪个特例 JavaScript 拥有动态类型JavaScript 拥有动态类型。这意味着相同变量可用作不同类型： 实例123var x; // 现在 x 是 undefinedvar x = 7; // 现在 x 是数值var x = "Bill"; // 现在 x 是字符串值 JavaScript 对象JavaScript 对象用花括号来书写。 对象属性是 name:value 对，由逗号分隔。 实例1var person = {firstName:"Bill", lastName:"Gates", age:62, eyeColor:"blue"}; Undefined 与 Null 的区别Undefined 与 null 的值相等，但类型不相等： 1234typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true typeof 运算符可返回以下原始类型之一： string number boolean undefined typeof 运算符可返回以下两种类型之一： function object typeof 运算符把对象、数组或 null 返回 object。 typeof 运算符不会把函数返回 object。 typeof 运算符把数组返回为 “object”，因为在 JavaScript 中数组即对象。 事件下面是一些常见的 HTML 事件： 事件 描述 onchange HTML 元素已被改变 onclick 用户点击了 HTML 元素 onmouseover 用户把鼠标移动到 HTML 元素上 onmouseout 用户把鼠标移开 HTML 元素 onkeydown 用户按下键盘按键 onload 浏览器已经完成页面加载 字符串.length 提取长度 查找： indexOf() lastIndexOf() search() 两种方法，indexOf() 与 search()，是相等的。 这两种方法是不相等的。区别在于： search() 方法无法设置第二个开始位置参数。 indexOf() 方法无法设置更强大的搜索值（正则表达式）。 您将在正则表达式的章节学习到这些更强大的检索值。 有三种提取部分字符串的方法： slice(start, end):负数索引，从后往前 substring(start, end)：类似⬆️，但不接受负数索引 substr(start, length)：不同之处在于第二个参数规定被提取部分的长度 数字🔢JavaScript 数值始终是 64 位的浮点数与许多其他编程语言不同，JavaScript 不会定义不同类型的数，比如整数、短的、长的、浮点的等等。 JavaScript 数值始终以双精度浮点数来存储，根据国际 IEEE 754 标准。 此格式用 64 位存储数值，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号： 值(aka Fraction/Mantissa) 指数 符号 52 bits(0 - 51) 11 bits (52 - 62) 1 bit (63) 在所有数字运算中，JavaScript 会尝试将字符串转换为数字： 该例如此运行： 123var x = "100";var y = "10";var z = x / y; // z 将是 10 NaN - 非数值NaN 属于 JavaScript 保留词，指示某个数不是合法数。 尝试用一个非数字字符串进行除法会得到 NaN（Not a Number）： InfinityInfinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值。 实例 12345var myNumber = 2;while (myNumber != Infinity) { // 执行直到 Infinity myNumber = myNumber * myNumber;} 全局方法JavaScript 全局方法可用于所有 JavaScript 数据类型。 这些是在处理数字时最相关的方法： 方法 描述 Number() 返回数字，由其参数转换而来。 parseFloat() 解析其参数并返回浮点数。 parseInt() 解析其参数并返回整数。 数值属性 属性 描述 MAX_VALUE 返回 JavaScript 中可能的最大数。 MIN_VALUE 返回 JavaScript 中可能的最小数。 NEGATIVE_INFINITY 表示负的无穷大（溢出返回）。 NaN 表示非数字值（”Not-a-Number”）。 POSITIVE_INFINITY 表示无穷大（溢出返回）。 实例 1var x = Number.MAX_VALUE; 数组方法 toString join pop push shift:方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引。方法返回被“位移出”的字符串 unshift:方法（在开头）向数组添加新元素，并“反向位移”旧元素,方法返回新数组的长度。 length属性 delete删除元素 Splice 添加或删除元素元素 Concat 合并数组 slice切片 slice(1). slice(1,3) toString 排序 sort 默认地，sort() 函数按照字符串顺序对值进行排序。 该函数很适合字符串（”Apple” 会排在 “Banana” 之前）。 不过，如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。 正因如此，sort() 方法在对数值排序时会产生不正确的结果。 我们通过一个比值函数来修正此问题： 实例 1234var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b){return a - b}); //升序points.sort(function(a, b){return a - b}); //降序 reverse Math.min/max.apply(null, arr) 迭代 forEach map filter reduce reduceRight every检测所有数组值是否通过测试 some检测部分数组值是否通过测试 indexOf 方法在数组中搜索元素值并返回其位置。 lastIndexOf 从数组结尾开始搜索。 find() 方法返回通过测试函数的第一个数组元素的值。 findIndex() 方法返回通过测试函数的第一个数组元素的索引。 日期📅创建Date 对象由新的 Date() 构造函数创建。 有 4 种方法创建新的日期对象： new Date() new Date(year, month, day, hours, minutes, seconds, milliseconds) 7个数字分别指定年、月、日、小时、分钟、秒和毫秒（按此顺序）您不能省略月份。如果只提供一个参数，则将其视为毫秒。 注释：JavaScript 从 0 到 11 计算月份。 一月是 0。十二月是11。 new Date(milliseconds)u new Date(date string) 格式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 动态规划经典题目]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[动态规划几道经典题目 621234567891011121314151617class Solution { //尝试用递归的思路进行求解 public int uniquePaths(int m, int n) { int ans = step(1, 1, m, n); return ans; } //递归函数 public int step(int i, int j, int m, int n){ if(i &gt; m || j &gt; n) return 0; if(i == m &amp;&amp; j == n) return 1; return step(i+1, j, m, n) + step(i, j+1, m , n); } //递归超时啦sad} 198 打家劫舍1234567891011121314151617//我的写法，自己思考出来的，但是写的不是很精炼class Solution { public int rob(int[] nums) { int len = nums.length; if(len == 0) return 0; if(len == 1) return nums[0]; int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); //dp[i] = max(dp[i-1], dp[i-2]+nums[i]) for(int i = 2; i&lt;len; i++){ dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i]); } return dp[len-1]; }} 123456789101112131415public int rob(int[] num) { int prevMax = 0; int currMax = 0; for (int x : num) { int temp = currMax; currMax = Math.max(prevMax + x, currMax); prevMax = temp; } return currMax;}作者：LeetCode链接：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 213 打家劫舍2123456789101112131415161718192021222324class Solution { public int rob(int[] nums) { int len = nums.length; if(len == 0) return 0; if(len == 1) return nums[0]; //第一种情况，第一家一定打劫，最后一家一定不打劫 int[] dp1 = new int[len]; dp1[0] = dp1[1] = nums[0]; for(int i = 2; i &lt; len-1; i++){ dp1[i] = Math.max(dp1[i-1], dp1[i-2] + nums[i]); } //第二种情况，第一家一定不打劫，最后一家一定打劫 int[] dp2 = new int[len]; dp2[0] = 0; dp2[1] = nums[1]; for(int i = 2; i &lt;len; i++){ dp2[i] = Math.max(dp2[i-1], dp2[i-2] + nums[i]); } return Math.max(dp1[len-2], dp2[len-1]); }} 1201234567891011121314151617181920212223242526272829//自顶向下，有O(n)的空间开销class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int n = triangle.size(); if(n == 0) return 0; int[] dp = new int[n]; dp[0] = triangle.get(0).get(0); int min = dp[0]; for(int i = 2; i &lt;= n; i++){ List&lt;Integer&gt; line = triangle.get(i-1); for(int j = i-1; j &gt;= 0; j--){ if(j == i-1){ dp[j] = dp[j-1] + line.get(j); min = dp[j]; } else if(j == 0){ dp[j] = dp[j] + line.get(j); } else{ dp[j] = Math.min(dp[j], dp[j-1]) + line.get(j); } if(i == n) min = min &lt; dp[j] ? min : dp[j]; } } // int min = dp[0]; // for(int i = 1; i&lt;n; i++) min = min &lt; dp[i] ? min : dp[i]; return min; }} 12345678910111213141516//自底向上求解class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int n = triangle.size(); if(n == 0 || triangle == null) return 0; int[] dp = new int[n+1]; for(int i = n-1; i &gt;= 0; i--){ List&lt;Integer&gt; down = triangle.get(i); for(int j = 0; j &lt;= i; j++){ dp[j] = down.get(j) + Math.min(dp[j], dp[j+1]); } } return dp[0]; }} 221.最大正方形 我们用 0 初始化另一个矩阵 dp，维数和原始矩阵维数相同； dp(i,j) 表示的是由 1 组成的最大正方形的边长； 从 (0,0)(0,0) 开始，对原始矩阵中的每一个 1，我们将当前元素的值更新为 $$\text{dp}(i,\ j) = \min \big( \text{dp}(i-1,\ j),\ \text{dp}(i-1,\ j-1),\ \text{dp}(i,\ j-1) \big) + 1dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1$$ 我们还用一个变量记录当前出现的最大边长，这样遍历一次，找到最大的正方形边长 maxsqlenmaxsqlen，那么结果就是 maxsqlen^2maxsqlen 作者：LeetCode链接：https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode/ 12345678910111213141516171819202122class Solution { public int maximalSquare(char[][] matrix) { int row = matrix.length; if(row == 0 || matrix == null) return 0; int col = matrix[0].length; int[] dp = new int[col+1]; int max = 0, prev = 0; for(int i = 1; i&lt;= row; i++){ for(int j = 1; j &lt;= col; j++){ int tmp = dp[j]; if(matrix[i-1][j-1] == '1'){ dp[j] = Math.min(Math.min(dp[j-1], dp[j]), prev) + 1; max = Math.max(max, dp[j]); } else { dp[j] = 0; } prev = tmp; } } return max * max; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution { public String longestPalindrome(String s) { int len = s.length(); if (len &lt; 2) { return s; } boolean[][] dp = new boolean[len][len]; // 初始化 for (int i = 0; i &lt; len; i++) { dp[i][i] = true; } int maxLen = 1; int start = 0; for (int j = 1; j &lt; len; j++) { for (int i = 0; i &lt; j; i++) { if (s.charAt(i) == s.charAt(j)) { if (j - i &lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i + 1][j - 1]; } } else { dp[i][j] = false; } // 只要 dp[i][j] == true 成立，就表示子串 s[i, j] 是回文，此时记录回文长度和起始位置 if (dp[i][j]) { int curLen = j - i + 1; if (curLen &gt; maxLen) { maxLen = curLen; start = i; } } } } return s.substring(start, start + maxLen); }}作者：liweiwei1419链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决hexo对emoji的支持问题]]></title>
    <url>%2F2020%2F04%2F08%2F%E8%A7%A3%E5%86%B3hexo%E5%AF%B9emoji%E7%9A%84%E6%94%AF%E6%8C%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原生hexo对emoji的支持不是很好，很多表情都没有办法显示，本文记录如何解决这种问题。 hexo默认的markdown渲染引擎hexo-renderer-marked不支持对emoji的渲染，解决方法就是换一个引擎，以及增加一个emoji插件。 安装 命令行如下： 123npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm install markdown-it-emoji --save 第一行是移除hexo默认的引擎，第二行是新安装的引擎，第三行是安装emoji插件。 ⚠PS:执行命令行时，在hexo博客所在的命令行进行，才会产生效果。 配置 在hexo博客所在目录下，配置站点信息_config.yml文件，配置情况如下。 123456789101112131415## markdown 渲染引擎配置，默认是hexo-renderer-marked，这个插件渲染速度更快，且有新特性markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-footnote - markdown-it-sup - markdown-it-sub - markdown-it-abbr - markdown-it-emoji 使用 复制你想要的emoji表情，粘贴到博文中 输入emoji表情编码，比如:smile:就是😄的编码～ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决homebrew下载过慢]]></title>
    <url>%2F2020%2F04%2F07%2F%E8%A7%A3%E5%86%B3homebrew%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2%2F</url>
    <content type="text"><![CDATA[homebrew原生镜像下载过慢，本博客给出解决方法 第一步：跟换镜像源 此处我是将homebrew的镜像源换成了清华镜像，相关操作如下 1234567cd "$(brew --repo)"git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.gitcd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitbrew update 第二步：更换homebred-bottles镜像 12echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profilesource ~/.bash_profile PS:如果使用的shell不是bash而是zsh的话，则把.bash_profile改成.zshrc document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo迁移]]></title>
    <url>%2F2020%2F04%2F06%2Fhexo%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[迁移hexo博客 最近换电脑了，需要把之前电脑上的hexo博客相关内容进行迁移。通过网上博客以及知乎上相关内容学习，最终迁移成功，写一下博客记录一下整个过程。 参考资料：使用hexo，如果换电脑了怎么办 GitHub同步hexo d部署到GitHub上的内容都是hexo编译后的文件，不包含本地的源文件。所以可以利用GitHub的分支管理，将源文件上传到GitHub的另一个分支。 hexo分支在自己的博客仓库创建一个hexo分支，如下图所示： 在仓库的设置settings中，选择默认分支为hexo分支，如下所示： 然后在本地的任意目录下，将自己的仓库clone下来 git clone git@github.com:xxx/xxx.github.io.git (PS:将xxx换成自己对应的名称) 打开该目录，保留.git文件，其余文件删除。把之前博客的源文件复制过来，除去.deploy_git文件。 ⚠注意，如果之前主题文件是通过克隆下来的，应该把主题文件中.git文件删除。原因是git不能嵌套上传，不删除的话主题文件会无法上传。 最后 123git add .git commit -m "hexo branch"git push 上传完毕，可以去hexo分支检查一下内容是否与本地一致。注意，node_modules、public、db.json三个文件因为.gitignore忽略上传了，分支没有这三个内容是正常情况。 迁移至新电脑首先，安装并配置git、npm、hexo 然后在任意目录下git clone你的博客 然后进入该文件夹，进行如下操作： 12npm installnpm install hexo-deployer-git --save 生成并部署hexo 博客：hexo g -d 然后就可以在该电脑继续写文章啦～😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDBC总结]]></title>
    <url>%2F2020%2F04%2F03%2FJDBC%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JDBC学习总结 考虑事务后的数据库操作 获取数据库连接 DriverClass url username password Connection conn = JDBCUtils.getConnection() 方法1：手动连接 方法2：数据连接池连接 conn.setAutoCommit(false) //体现事务 如下的多个DML操作，作为一个事务出现 操作1：需要使用通用的增删改查操作 操作2：需要使用通用的增删改查操作 操作3：需要使用通用的增删改查操作 conn.commit() CRUD如何实现？ 方法1：手动使用PreparedStatement实现 方法2：使用dbUtils.jar中QurryRunner类 如果出现异常 conn.rollback() 关闭资源 JDBCUtils.closeResource() 方法1：手动关闭 方法2：DbUtils类关闭 两种编程思想面向接口编程的思想 ORM编程思想：（object relational mapping） 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 数据库事务概念1.事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 一组逻辑操作单元：一个或多个DML操作。2.事务处理的原则：保证所事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。 说明：1.数据一旦提交，就不可回滚 2.哪些操作会导致数据的自动提交？ DDL操作一旦执行，都会自动提交。 set autocommit = false 对DDL操作失效 DML默认情况下，一旦执行，就会自动提交。 我们可以通过set autocommit = false的方式取消DML操作的自动提交。 默认在关闭连接时，会自动的提交数据 事务的ACID属性 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 数据库的并发问题对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 四种隔离级别数据库提供的4种事务隔离级别： 手动实现方法数据库连接与关闭12345678910111213141516171819202122232425/** * 获取数据库的连接 * @return * @throws Exception */@Testpublic static Connection getConnection() throws Exception{ // 1.读取配置信息 InputStream inputStream = ClassLoader.getSystemClassLoader().getResourceAsStream("jdbc.properties"); Properties properties = new Properties(); properties.load(inputStream); String user = properties.getProperty("user"); String password = properties.getProperty("password"); String url = properties.getProperty("url"); String driverClass = properties.getProperty("driverClass"); // 2.加载驱动 Class.forName(driverClass); // 3.获取连接 Connection connection = DriverManager.getConnection(url, user, password); return connection;} 123456789101112131415161718192021222324/** * @description 关闭数据库连接 * @param connection * @param ps * @param rs *///选择性关闭Connection, Statement, ResultSetpublic static void closeResource(Connection connection, Statement ps, ResultSet rs){ try { if(rs != null) rs.close(); } catch (SQLException e){ e.printStackTrace(); } try { if(ps != null) ps.close(); } catch (SQLException e){ e.printStackTrace(); } try { if(connection != null) connection.close(); } catch (SQLException e){ e.printStackTrace(); }} PreparedStatement实现增删改查获取当前泛型参数 12345678910private Class&lt;T&gt; clazz = null;{ //获取当前BaseDAO的子类继承的父类中的泛型 Type genericSuperclass = this.getClass().getGenericSuperclass(); ParameterizedType paramType = (ParameterizedType) genericSuperclass; Type[] typeArguments = paramType.getActualTypeArguments();//获取了父类的泛型参数 clazz = (Class&lt;T&gt;) typeArguments[0];//泛型的第一个参数} 增删改操作 12345678910111213141516171819202122// 通用的增删改操作---version 2.0 （考虑上事务）// 实现时记得考虑事物操作public int update(Connection conn, String sql, Object... args) {// sql中占位符的个数与可变形参的长度相同！ PreparedStatement ps = null; try { // 1.预编译sql语句，返回PreparedStatement的实例 ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]);// 小心参数声明错误！！ } // 3.执行 int count = ps.executeUpdate(); return count; } catch (Exception e) { e.printStackTrace(); } finally { // 4.资源的关闭 JDBCUtils.closeResource(null, ps); } return 0;} 查询操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 通用的查询操作，用于返回数据表中的一条记录（version 2.0：考虑上事务public T getInstance(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据 :ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 通过ResultSetMetaData获取结果集中的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) { T t = clazz.newInstance(); // 处理结果集一行数据中的每一个列 for (int i = 0; i &lt; columnCount; i++) { // 获取列值 Object columValue = rs.getObject(i + 1); // 获取每个列的列名 // String columnName = rsmd.getColumnName(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); // 给t对象指定的columnName属性，赋值为columValue：通过反射 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null;}// 通用的查询操作，用于返回数据表中的多条记录构成的集合（version 2.0：考虑上事务public List&lt;T&gt; getForList(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据 :ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 通过ResultSetMetaData获取结果集中的列数 int columnCount = rsmd.getColumnCount(); // 创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) { T t = clazz.newInstance(); // 处理结果集一行数据中的每一个列:给t对象指定的属性赋值 for (int i = 0; i &lt; columnCount; i++) { // 获取列值 Object columValue = rs.getObject(i + 1); // 获取每个列的列名 // String columnName = rsmd.getColumnName(i + 1); String columnLabel = rsmd.getColumnLabel(i + 1); // 给t对象指定的columnName属性，赋值为columValue：通过反射 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null;} PreparedStatement实现批操作的范例1234567891011121314151617181920212223242526272829303132333435/** * 批量插入方式4 * 1.addBatch, executeBatch, clearBatch * 2.整个批处理作为一个事务提交 */@Testpublic void testInsert4(){ String sql = "insert into goods(name) values(?)"; try (Connection conn = JDBCUtils.getConnection(); PreparedStatement ps = conn.prepareStatement(sql)){ //关闭自动提交 conn.setAutoCommit(false); long start = System.currentTimeMillis(); for(int i = 1; i&lt;=1000000; i++){ ps.setObject(1, "name_" + i); //1.攒sql ps.addBatch(); if(i % 500 == 0) { ps.executeBatch(); ps.clearBatch(); } } //批处理结束后一起提交 conn.commit(); long end = System.currentTimeMillis(); System.out.println("总用时:" + (end - start)); } catch (Exception e) { e.printStackTrace(); }} PreparedStatement操作Blob类型12345678910111213141516171819//向数据库中插入blob类型@Testpublic void testInsert(){ String sql = "insert into customers(name, email, birth, photo) values(?,?,?,?)"; try(Connection conn = JDBCUtils.getConnection(); PreparedStatement ps = conn.prepareStatement(sql)) { ps.setObject(1, "大哥"); ps.setObject(2, "big@qq.com"); ps.setObject(3, "1999-03-02"); //设置Blob输入流 FileInputStream is = new FileInputStream(new File("src/volume2/jdbc/no3Blob/big.jpg")); ps.setBlob(4, is); ps.execute(); } catch (Exception e) { e.printStackTrace(); }} 数据库连接池Druid &amp; DbUtils实现Druid数据库连接池创建12345//连接属性设置username = rootpassword=11235813url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;rewriteBatchedStatements=truedriverClassName=com.mysql.cj.jdbc.Driver 12345678910111213141516171819202122/** * @description Druid数据库连接池连接 * @throws Exception */private static DataSource source = null;static { try { //设置连接属性 Properties pros = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("druid.properties"); pros.load(is); source = DruidDataSourceFactory.createDataSource(pros); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); }}public static Connection druidGetConnection() throws Exception { Connection conn = source.getConnection(); return conn;} DbUtils实现增删改查增删改示例 12345678910111213@Test//通过QueryRunner来实现public void testInsert() { try(Connection connection = JDBCUtils.druidGetConnection()){ QueryRunner runner = new QueryRunner(); String sql = "insert into customers(name, email, birth)values(?, ?, ?)"; runner.update(connection, sql, "小火","huo@qq.com","1999-01-01"); } catch (SQLException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); }} 查询示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//测试查询/* * BeanHander:是ResultSetHandler接口的实现类，用于封装表中的一条记录。 */@Testpublic void testQuery1(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = "select id,name,email,birth from customers where id = ?"; BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); }finally{ JDBCUtils.closeResource(conn, null); }}/* * BeanListHandler:是ResultSetHandler接口的实现类，用于封装表中的多条记录构成的集合。 */@Testpublic void testQuery2() { Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = "select id,name,email,birth from customers where id &lt; ?"; BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); } catch (SQLException e) { e.printStackTrace(); }finally{ JDBCUtils.closeResource(conn, null); }} 查询特殊值示例 123456789101112131415161718192021222324/* * ScalarHandler:用于查询特殊值 */@Testpublic void testQuery5(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = "select count(*) from customers"; ScalarHandler handler = new ScalarHandler(); Long count = (Long) runner.query(conn, sql, handler); System.out.println(count); } catch (SQLException e) { e.printStackTrace(); }finally{ JDBCUtils.closeResource(conn, null); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑期实习 面经]]></title>
    <url>%2F2020%2F03%2F26%2F%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0-%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[腾讯的暑期实习面经~ 背景介绍本人是华中科技大学计算机专业大三的学生，应聘的是腾讯Java后端开发。技术不是很强，没怎么做过Java的开发，只是熟悉Java语法，对计网、操作系统这些方面有所了解，最近才学的MySQL，只会写一些SQL语言。 提前批一面面试官上来先介绍了他们组做的工作，他们是微信部门一个做游戏平台的部门，然后主要用的是C++， 看我这边投的的Java开发，所以问我愿不愿意做这方面。我就说没啥问题吧。然后就开始自我介绍balabala。 Java final关键字的作用 == 和 equals的区别 常用的集合类有哪些？哪些是线程安全的？ Java如何开启一个新的线程？（多线程这块我不是很熟悉，就说了通过Thread和实现Runnable接口） JVM垃圾回收算法你能讲一讲么？（不会。。） 操作系统 进程间同步的方式有哪些？Linux中terminal运行程序时按ctrl+C终止程序，属于哪一种同步方式？（第二个我答错了，面试官说是信号，我突然想起来操作系统实验有做过相关的……） 线程是如何进行同步的？（不知道..） 僵尸进程和孤儿进程你了解么？（emmm，都不知道） 如何查看CPU使用率？如何查看磁盘使用情况？ awk sed这两个命令有用过么？（用过，但不是很会） 如何查看进程使用的端口号？ 做题 实现一个栈，要求返回最小元素的时间复杂度为O(1) 看到这个题目有点懵逼，之前看公众号的时候有看到过这个题目，但是我忘了怎么解决了orz…想了有一会，说了一个解决方案但是有问题被否了。最后没想出来就跟面试官讲了。面试官还给我讲了该怎么解决，用另一个栈来存储最小元素，出栈入栈的时候进行判断就行了。自己还是太菜了。 数据库 数据库你了解么？ 哎，这个方面真的吃了大亏。学校数据库这门课开得太晚了，之前自己也没深入学习数据库相关的内容，面试时基本都是必问的。所以最近在疯狂补相关知识。面试官问了我就坦白不是很会，目前只会写一些SQL增删改查，但我已经在学了，就也没多问了。 面试结束，面试官问我有没有什么要问的，我就请他评价一下我这次的面试。他说Java这块语言掌握的还行，但JVM还是要了解一下（在看书了…）。Linux进程这块不是很熟练，建议我看一看那本《Unix系统环境高级编程》（好像是这本书？），学习一下。 一面差不多就这些。总的来说感觉问的不算很难吧，总共面试才二十几分钟。虽然也有挺多答不上来的点，但总体体验良好，不会的面试官也会把答案给你讲一下，算是消除了自己对于面试的恐惧心理吧。 一面刚才那面完了没一小时就有tx的邮件，让第二天早上电话面试，官网一查还是初试，群里咨询说可能是交叉面，就没管了。到了约定时间面试官忙着，后来跟我换了个时间。 面试开始了我才知道原来不是一个部门了，是一个新的部门，主要做的是Linux系统资源监控平台这么个工作，看到我简历里有写相关内容，所以就发起面试了。具体技术内容没怎么问，主要介绍了一下他们是做什么的，然后我问了一下我如果去了，提前需要对哪些技术方面准备一下，他就沿着架构组成部分都给我讲了一下。然后他让我介绍了一下我做的Linux系统监视器和MIPS CPU设计，就介绍了一下。这面基本就差不多了。 这次面试有点出乎我的意料，面试官没问什么技术方面，重点在我是否对他们做的这个方向感兴趣，还挺好的，希望能继续走下去~ 二面本来官网显示状态还是复试，时间尚未约定，做着作业突然收到了面试官的电话，就开始面试了。 这一面也没问什么技术性的问题，主要就是就两个项目Linux系统监视器和MIPS CPU问了问。问了为什么要做这些项目，是学校课程还是个人兴趣，怎么实现的，实现的时候有什么难点。然后又问我主要用Java，为什么没写Java项目，然后我就水了一下软工的那个项目。又问了一些以后更想往哪个方向发展，是否读研这些规划上的问题。最后问了下暑期实习时间安排。差不多这些就完了。事发突然，也没问什么技术难点，所以他问我有什么想问的没，我这也没上想问的，就挂电话了。 本来觉得自己表现得还凑合？十分钟后官网查询，发现自己被挂了，💔. 哎，挂的不明不白的，继续努力吧。 正式批事务型开发 一面 5.8上来就自我介绍，项目经历也拉垮地介绍了一下。问了一下平时主要做什么的，Java有没有做出什么项目（没有……）。了解完了就让我用Java实现一下归并排序，然后就让我自己做。早上才复习的归并，做的时候有点紧张了，有个点写错了，code估计10min，找bug都找了估计有10min。写完了给面试官说了一下，他检查了一下代码，看了看测试用例没问题就开始继续问问题。 JVM垃圾回收机制了解哪些？（不了解 AOP有用过么，聊一聊我的理解？（昨天才学，没啥理解…… Linux相关问题 平时我用的那些命令 awk/sed 熟悉么（no netstat熟悉么，tcp有哪些状态你知道么(netstat有用过，但是真的不熟悉，状态什么的也不知道 （感觉面试官不知道该问我啥了。。）感觉你平时代码写的有点少啊，Java都做了些什么？问我觉得自己擅长什么，这个地方答的也不是很好吧。。就问完了。 提问环节 能不能评价一下刚才的面试 面试官说我这个基础不是很好，简历里面写的有Linux系统资源监视器，问问题感觉了解的不是很多。有点浮于表面，没有深入挖掘 事务型开发是什么？有点好奇 事务型开发源自于数据库事务这个概念，部门做的是金融相关的方向，所以对于事务属性看的很重，对这个方面有侧重，所以叫事务型开发，本质还是后台开发。 总结 这段时间拼命的学习，补充自己不会的东西，感觉总结还是少了，虽然跟着别人做东西，但是没有自己总结回顾。学完了这些技能之后，一定要自己做出点项目然后总结总结。另外我发现JVM和Linux还需要好好学习一下，JVM不说别的，垃圾回收还是要知道掌握的，Linux常用命令也要熟悉一下。加油💪 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法 Java实现]]></title>
    <url>%2F2020%2F03%2F23%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-Java%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[用Java把常见的排序算法实现了一遍 冒泡排序12345678910111213141516171819202122/** * 冒泡排序，升序实现 * @param arr:需要排序的数组 */public static void bubbleSort(int[] arr){ /** * 添加一个标志位didSwap * 如果数组已经是升序排列，则只需要遍历一遍就可以结束遍历，此时时间复杂度为O(n) */ boolean didSwap = false; for(int i = 0; i&lt;arr.length-1; i++){ for(int j = i+1; j&lt;arr.length; j++){ if(arr[j] &lt; arr[i]){ int tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp; didSwap = true; } } if(didSwap == false) return; }} 插入排序12345678910111213141516/** * 插入排序 * 升序实现 * @param arr:需要排序的数组 */public static void insertSort(int[] arr){ int num; for(int i = 1; i&lt;arr.length; i++){ num = arr[i]; int j; for(j = i -1; j&gt;=0 &amp;&amp; arr[j] &gt; num; j--){ arr[j+1] = arr[j]; } arr[j+1] = num; }} 选择排序1234567891011121314151617181920/** * 选择排序，升序实现 * @param arr:需要排序的数组 */public static void selectSort(int[] arr){ for(int i = 0; i &lt; arr.length-1; i++){ int min = arr[i]; int place = 0; for(int j = i+1; j&lt;arr.length; j++){ if(arr[j] &lt; min){ min = arr[j]; place = j; } } int tmp = arr[place]; arr[place] = arr[i]; arr[i] = tmp; }} 希尔排序123456789101112131415161718192021/** * 希尔排序，升序实现 * @param arr:需要排列的数组 */public static void shellSort(int[] arr){ int len = arr.length; while (len != 0){ len /= 2; for(int i = 0; i&lt;len; i++){ for(int j = i + len; j&lt;arr.length; j += len){ int k = j - len; int tmp = arr[j]; while (k &gt;= 0 &amp;&amp; tmp &lt; arr[k]){ arr[k+len] = arr[k]; k -= len; } arr[k+len] = tmp; } } }} 归并排序1234567891011121314151617181920212223242526272829303132333435363738/** * 归并排序 * 升序排列int数组 * @param A:需要排列的数组 * @param lo:数组起始下标 * @param hi:数组结束下标 */public static void mergeSort(int[] A, int lo, int hi){ //升序方式排列数组 //如果lo&gt;=hi,说明数组中只有一个元素，应该返回 if(lo &gt;= hi) return; //取中位数 int mid = lo + (hi-lo)/2; //左右递归两遍的数组 mergeSort(A, lo, mid); mergeSort(A, mid+1, hi); //递归结束,进行合并 merge(A, lo, mid, hi);}private static void merge(int[] nums, int lo, int mid, int hi){ //复制原来的数组 int[] cp = nums.clone(); //k表示从什么位置修改原来的数组,i是左边开始的起始位置,j是右边开始的起始位置 int k = lo, i = lo, j = mid+1; while (k &lt;= hi){ //如果左边已经放置完了,就直接放置右边剩下的 //如果右边已经放置完了,就直接放置左边剩下的 //如果左边大于右边,则放置右边,否则放置左边. if(i &gt; mid) nums[k++] = cp[j++]; else if(j &gt; hi) nums[k++] = cp[i++]; else if(cp[i] &gt; cp[j]) nums[k++] = cp[j++]; else nums[k++] = cp[i++]; }} 快速排序12345678910111213141516171819202122232425262728293031/** * 快速排序 * 升序排列int数组 * @param nums:需要排列的数组 * @param lo:数组起始下标 * @param hi:数组结束下标 */public static void quickSort(int[] nums, int lo, int hi){ //如果只有一个元素了,则返回 if(lo &gt;= hi) return ; //获取参照值 int p = partition(nums, lo, hi); //把比p小的放到左边,比p大的放到右边 quickSort(nums, lo, p-1); quickSort(nums, p+1, hi);}private static int partition(int[] nums, int lo, int hi){ int tmp = nums[lo]; while (lo &lt; hi){ while (lo &lt; hi &amp;&amp; nums[hi] &gt; tmp) hi--; nums[lo] = nums[hi]; while (lo &lt; hi &amp;&amp; nums[lo] &lt; tmp) lo++; nums[hi] = nums[lo]; } nums[lo] = tmp; return lo; //返回中轴位置} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统复习]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[面试时复习操作系统知识 讲一讲，线程与进程的区别作者：路人甲链接：https://zhuanlan.zhihu.com/p/23755202来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 （四）什么是缓冲区溢出？有什么危害？其原因是什么？ 缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。 危害有以下两点： 程序崩溃，导致拒绝额服务 跳转并且执行一段恶意代码 造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。 （五）什么是死锁？死锁产生的条件？ 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。 死锁产生的四个条件（有一个条件不成立，则不会产生死锁） 互斥条件：一个资源一次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系 （六）进程有哪几种状态？ 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数 阻塞状态： 进程等待某种条件，在条件满足之前无法执行 面经作者：NULL链接：https://zhuanlan.zhihu.com/p/97843134来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 进程和线程以及它们的区别 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发； 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发； 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在； 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。 进程间的通信的几种方式 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等； 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段； 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。 死锁的概念在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。 死锁产生的四个必要条件 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止； 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有； 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系 死锁的处理基本策略和常用方法 解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等。 死锁预防 死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法包括： 打破互斥条件：允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的，因此，这种办法通常并无实用价值。 打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。 打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。 打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。 死锁避免的基本思想 死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。 死锁解除 死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题： 选择一个牺牲品 回滚：回滚到安全状态 饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能继续被作为牺牲品，避免一个进程总是被回滚） 进程有哪几种状态？ 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源； 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数； 阻塞状态： 进程等待某种条件，在条件满足之前无法执行； 操作系统中进程调度策略有哪几种？ FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。 分页和分段有什么区别（内存管理）？段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。 两者的不同点： 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息； 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定； 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间； 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制； 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。 页面置换算法 FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）； LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断； LFU（Least frequently use）最少使用次数算法：根据使用次数来判断； OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络复习]]></title>
    <url>%2F2020%2F03%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[面试时复习计算机网络知识 TCPTCP首部格式三次握手的过程四次挥手的过程HTTP浏览器输入网址到显示主页的整个过程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改写equals()和hashCode()]]></title>
    <url>%2F2020%2F03%2F19%2F%E6%94%B9%E5%86%99equals-%E5%92%8ChashCode%2F</url>
    <content type="text"><![CDATA[如何改写equals()和hashCode()方法 equalsObject类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，他们一定是相等的。然而，经常需要检测两个对象状态的相等性，如果两个对象的状态相等，就认为这两个对象是相等的。 equals具有下面的特性： 自反性：对任何非空引用x，x.equals(x)应该返回true 对称性：对任何非空引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true 传递性 一致性：如果x和y引用的对象没有发生变化呢，反复调用应该返回相同的结果 对任意非空引用x,x.equals(null)应该返回false 编写equals的建议（放在下面的代码中） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Employee { private String name; private double salary; private LocalDate hireDay; public Employee(String name, double salary, int year, int month, int day){ this.name = name; this.salary = salary; hireDay = LocalDate.of(year, month, day); } public String getName(){ return name; } public double getSalary() { return salary; } public LocalDate getHireDay(){ return hireDay; } public void raiseSalary(double percent){ salary = salary * (1 + percent/100); } public boolean equals(Object otherObject){ if(this == otherObject) return true; if(otherObject == null) return false; if(getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return Objects.equals(name, other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); } public int hashCode(){ return Objects.hash(name, salary, hireDay); } public String toString(){ return getClass().getName() + "[name=" + name + " ,salary=" + salary + " ,hireDay=" + hireDay +"]"; }} 1234567891011121314151617181920212223242526272829303132public class Manager extends Employee { private double bonus; public Manager(String name, double salary, int year, int month, int day){ super(name, salary, year, month, day); bonus = 0; } public double getSalary(){ return super.getSalary() + bonus; } public void setBonus(double b){ bonus = b; } public boolean equals(Object otherObject){ if(!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; } public int hashCode(){ return super.hashCode() + 17*Double.hashCode(bonus); } public String toString(){ return super.toString() + "[bonus=" + bonus + "]"; }} 123456789101112131415161718192021222324252627public class EqualsTest { public static void main(String[] args) { Employee alice1 = new Employee("Alice Adams", 75000, 1987, 12, 15); Employee alice2 = alice1; Employee alice3 = new Employee("Alice Adams", 75000, 1987, 12, 15); Employee bob = new Employee("Bob Brandson",50000, 1989, 10, 1); System.out.println("alice1 == alice2:" + (alice1 == alice2));//true System.out.println("alice1 == alice3:" + (alice1 == alice3));//false System.out.println("alice1.equals(alice3):" + (alice1.equals(alice3)));//true System.out.println("alice1.equals(bob):" + (alice1.equals(bob)));//false System.out.println("bob.toString:" + bob); Manager carl = new Manager("Carl Cracker", 80000,1987,12,15); Manager boss = new Manager("Carl Cracker", 80000,1987,12,15); boss.setBonus(5000); System.out.println("boos.toString():" + boss); System.out.println("carl.equals(boss):" + carl.equals(boss)); System.out.println("alice1.hashCode():" + alice1.hashCode()); System.out.println("alice3.hashCode():" + alice3.hashCode()); System.out.println("bob.hashCode():" + bob.hashCode()); System.out.println("carl.hashCode():" + carl.hashCode()); }} equals 和 ==的区别对于 == 来说比较两个对象时，实质上是检查对象的内存地址是否相等 原生Objects.equals其实也是这么干的 为什么要重写hashCode()原生hashCode方法到处的是对象存储地址。 由于定义equals与hashCode的定义必须一致：如果x.equals(y) 返回true，那么x.hashCode()必须等于y.hashCode()。所以当我们修改了equals方法后，应该也修改hashCode方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 关键字]]></title>
    <url>%2F2020%2F03%2F19%2FJava-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final、abstract、protected关键字 final 对类。阻止该类被继承。如果一个类声明为final，其中的方法自动成为final，但不包含域 对方法。子类不能覆盖这个方法 将方法或类声明为final的主要目的是：确保它们不会再子类中改变语义 对基本类型。赋值后不能修改其值 对引用类型。确定引用后，不能更改引用 abstract抽象类包含一个或多个抽象方法的类本身必须被声明为抽象的。 类即使不喊抽象方法，也可声明为抽象类，作用是该类不可被实例化。可以定义一个抽象类的对象变量，但是只能引用非抽象的子类对象。 protected人们希望父类中的某些方法允许被子类访问，或允许子类的方法访问父类的某个域。为此需要将这些方法或域声明为protected。 访问修饰符： 仅对本类可见——private 对所有类可见——public 对本包和所有子类可见——protected 对本包可见——默认，不需要修饰符 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flink 简介]]></title>
    <url>%2F2020%2F03%2F14%2FFlink-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Flink刚入门时候讲的背景知识 主要内容 Flink是什么 为什么要用Flink 流处理的发展和演变 Flink的主要特点 Flink vs Spark Streaming Flink是什么Apache Flink是一个框架和分布式处理引擎，用于对无界和有解数据流进行状态运算 为什么选择Flink 流数据更真实地反映了我们的生活方式 传统的数据架构是基于有限数据集的 目标 低延迟 高吞吐 结果的准确性和良好的容错性 行业进行流处理举例 电商和市场销售数据报表、广告投放、业务流程需要 物联网传感器实时数据采集和显示、实时报警、交通运输业 电信业基站流量调配 银行和金融业实时结算和通知推送、实时检测异常行为 流处理的发展和演变第一代流处理：来一个处理一个 优点：低延迟 第二代流处理：lambda架构 通过结合批处理和流处理，来做到低延迟和准确性 缺点是架构复杂，同时维护两套系统运维成本高 第三代流处理：flink 相对于spark streaming通过micro-batch来实现流处理，flink为纯流处理 Flink使用场景事件驱动型应用 数据分析应用 数据管道应用 Flink特点 纯流处理 分层API 支持事件时间和处理时间语义 exactly-once的状态一致性保证 低延迟，每秒处理书包玩个事件，毫秒级延迟 与众多常用存储系统的连接 高可用，动态扩展 Flink vs Spark Streamingstream &amp; micro-batch 取决于看问题的角度，微批小到一个事件时，就是流处理，反之流处理也能看成批处理 数据模型 spark采用RDD模型，spark streaming的DStream实际上也就是一组组小批数据RDD的集合 flink基本数据模型是数据流，以及事件序列 运行架构 spark是批计算，将DAG划分为不同的stage，一个完成后才可以计算下一个 flink是标准的流执行模式，一个事件字一个节点处理完后可以直接发往下一个节点进行处理 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flink之容错机制]]></title>
    <url>%2F2020%2F03%2F14%2FFlink%E4%B9%8B%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[关于Flink的checkpoint机制 主要内容 一致性检查点（checkpoint） 从检查点回复状态 检查点算法 保存点（save points） 一致性检查点 checkpoint 故障恢复机制的核心：应有状态的一致性检查点 有状态流应用的一致检查点，其实就是所有任务的状态，在某个时间点的一份拷贝（快照）。在这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候 从检查点恢复 执行流应用程序期间，Flink会定期保存状态的一致检查点 如果发生故障，会使用最近的检查点来一致恢复应用程序的状态，并重新启动处理流程 遇到故障，第一步：重启应用 第二步：从checkpoint中读取状态，将状态重置 从检查点重新启动应用后，其内部状态与检查点完成时的状态完全相同 第三步：开始消费并处理检查点到发生故障之间的所有数据 这种你差点的保存和恢复机制可以为应用程序状态提供exactly-once的一致性，因为所有算子都会保存检查点并恢复所有状态，这样一来，所有的输入流都会被充值到检查点完成时的位置 算法实现简单实现：暂停应用，保存状态到检查点，再重新恢复应用 ⬇ Flink的改进实现： 基于Chandy-Lamport算法的分布式快照 将检查点的保存和数据处理分开，不暂停整个应用 检查点分界线（checkpoint barrier） 检查点算法用到了一种叫做分界线的特殊数据形式，用来把一条流上数据按照不同的检查点分开 分界线之前到来的数据状态导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中 实例分析 现在是一个有两个输入流的应用程序，并行两个Source任务来读取 JobManager会向每个Source任务发送一条带有新检查点ID的消息，通过这种方式启动检查点 数据源将它们的状态写入检查点，并发出一个检查点barrier 状态后端在状态存入检查点之后，会返回通知给source任务，任务回向JobManager确认检查点完成 分界线对齐：barrier向下游传递，sum任务会等待所有输入分区的barrier到达 对barrier已经到达的分区，继续到达的数据会被缓存 对barrier还未到达的分区，数据会被正常处理 当收到所有输入分区的barrier时，任务就将其状态保存到状态后端的检查点中，然后将barrier继续向下游转发 向下游转发检查点barrier后，任务继续正常的数据处理 sink任务向JobManager确认状态保存到checkpoint完毕 当所有任务都确认已成功将状态保存到检查点时，检查点就真正完成了 保存点(Savepoint)Flink提供了可以自定义的镜像保存功能，就是savepoint 原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为就是具有一些额外元数据的检查点 Flink不会自动创建保存点，因此用户（或外部调度程序）必须明确地触发创建操作 保存点是一个强大的功能。除了故障恢复外，保存点可以用于：有计划地手动备份，更新应用程序，版本迁移，暂停和重启应用等 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库概念及初识MySQL]]></title>
    <url>%2F2020%2F03%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%9D%E8%AF%86MySQL%2F</url>
    <content type="text"><![CDATA[为什么要学数据库？ 为什么学习数据库生活中的常识: 记账 帐➡数据/信息记账➡存储数据/信息 无论记在哪儿：记录的都是信息，变化的只是信息的载体 一台服务器下有多个库，一个库下有一到多张表，一个表有多行多列的数据 好处： 实现数据持久化 使用完整的管理系统统一管理，易于查询 数据库相关概念DB:存储数据的仓库，保存了一系列有组织的数据 DBMS:数据库管理系统，简称数据库软件或数据库产品。MySQL属于其中的一种管理系统。数据库通过DBMS创建和操作的容器 SQL:结构化查询语言(Structure Query Language)。专门用来与数据库通信的语言 SQL的优点： 不是某个特定数据库供应商专有语言，几乎所有DBMS都支持SQL 简单易学 简单但是高效，灵活使用其他语言，可以进行非常复杂和高级的数据库操作 数据库存储数据的特点 将数据放到表里，表再放到库中 一个数据库中可以有多个表，每个表都有一个名字，用来表示自己。表具有唯一性 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java中“类”的概念 表由列组成，我们称之为字段。所有表都是由一个或者多个列组成的，每一列类似Java中的“属性” 表中的数据是按行存储的，每一行类似Java中的“对象” MySQL软件介绍优点： 成本低：开源免费 性能高：执行块 简单：容易安装使用 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础]]></title>
    <url>%2F2020%2F03%2F13%2FJava-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[复习Java基础内容 Java SE基础int和Integer有什么区别？Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型：- 原始类型: boolean，char，byte，short，int，long，float，double- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 请你说明String 和StringBuffer的, StringBuilderJAVA 平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。 在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String StringBuffer 字符串变量（线程安全）StringBuilder 字符串变量（非线程安全） StringBuilder为什么线程不安全 请说明String是最基本的数据类型吗?基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。 请你解释什么是值传递和引用传递值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.一般认为,java内的传递都是值传递. 什么是自动拆装箱？自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 请你说明符号“==”比较的是什么？“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。“==”如果两边是基本类型，就是比较数值是否相等。 请你解释为什么重写equals还要重写hashcode？请你介绍一下map的分类和常见的情况java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap. Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。 Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。 Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。 LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。 一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列. 关键字当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 请你谈谈关于Synchronized和locksynchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 计算机网络网络概述网络模型 一、OSI七层协议模型 OSI的七层协议主要包括：物理层（physical layer）、数据链路层（data link layer）、网络层（network layer）、运输层（transport layer）、会话层（session layer）、表示层（presentation layer）、应用层（application layer）。 -———————————————————————————————————- 二、TCP/IP四层协议模型 TCP/IP是一个四层的体系结构，他包括（从下到上顺序）：网络接口层、网际层（用网际层这个名字是强调这一层是为了解决不同的网络的互联问题）、运输层、应用层。不过从实质上讲，TCP/IP只有最上面的三层，因为最下面的网络接口层并没有具体内容。 -————————————————————————————————– 三、五层协议体系结构 五层体系的协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：物理层、数据链路层、网络层、运输层、应用层。（最底下两层可以称为网络接口层） 注：五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是TCP/IP四层体系结构。 1、物理层 主要定义物理设备标准，例如网线的接口类型、光线的接口类型、各种传输介质的传输速率等。他的主要作用是传入比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们通常所说的数模转换与模数转换）。这一层的数据叫做比特流。。 2、数据链路层 定义了如何让数据格式化进行传输，以及如何让控制对物理介质的访问。这一层通常还提供了错误检测和纠正，以保证数据的可靠传输。 3、网络层 在位于不同地理位置的网络中的两个主机之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 4、运输层 定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议TCP，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）和UDP（用户数据报协议UDP，与TCP特性恰恰相反，用于传输可靠性要求不高、数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层的接收的数据进行分段和传输，到达目的地后再进行传输。常常把这一层数据叫做段。 5、会话层 通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者就受会话请求（设备之间需要相互认识可以是IP地址也可以是MAC地址或者主机名）。 6、表示层 可以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台程序计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通用格式来实现多种数据格式之间的转换。 7、应用层 是最靠近用户的OSI层。这一层为用户的应用程序（如：电子邮件、文件传输和仿真终端）提供网络服务。 运输层请讲一下浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面 请说明一下http和https的区别1)https协议要申请证书到ca，需要一定经济成本； 2） http是明文传输，https是加密的安全传输； 3） 连接的端口不一样，http是80，https是443； 4）http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>面试复习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flink之时间语义和watermark]]></title>
    <url>%2F2020%2F03%2F12%2FFlink%E4%B9%8B%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89%E5%92%8Cwatermark%2F</url>
    <content type="text"><![CDATA[Flink中很重要的时间的概念以及一个跟时间有关的watermark 时间语义 事件时间和处理时间举例 不同的时间语义有不同的应用场合 往往更关心事件时间 代码中设置Event Time 代码中,对执行环境调用setStreamTimeCharacteristic方法,设置流的时间特性 具体的时间,需要从数据中提取时间戳(timestamp) 默认时间为处理时间(processing time) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) 乱序数据的影响 以event time模式处理数据流时,会根据时间戳来处理基于时间的算子 由于网络,分布式等原因,会导致乱序数据的产生 乱序数据会让窗口计算不准确 水位线 Watermark 如何避免乱序数据带来计算不正确? 遇到一个时间戳达到窗口关闭时间,不应该立刻触发窗口计算,而是等待一段时间,等迟到的数据来了再关闭窗口 Watermark是一种衡量Event Time进展的机制,可以设定延迟触发 Watermark是用于处理乱序事件的,而正确的处理乱序事件,通常采用Watermark机制结合window实现 数据流中的Watermark用于表示timestamp小于Watermark的数据都已经到达,因此,window的执行也是由Watermark触发的 Watermark用来让程序自己平衡延迟和结果正确性 Watermark特点 Watermark必须单调递增,以确保任务的事件时间时钟在向前推进,而不是后退 Watermark与数据的timestamp相关 Watermark的传递 Watermark的引入Event Time的使用一定要指定数据源中的时间戳 Watermark的设定需要对处理的事件有一定了解 如果设置的延迟太久,收到结果的速度可能就会很慢,解决办法是在水位线到达之前输出一个近似结果 如果到达太早,则可能收到错误结果,不过Flink处理迟到数据的机制可以解决这个问题 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flink之transformation]]></title>
    <url>%2F2020%2F03%2F12%2FFlink%E4%B9%8Btransformation%2F</url>
    <content type="text"><![CDATA[Flink数据处理的重头,本文仅简单介绍 基本算子map对数据进行转换,一个数据转换成另一个数据 flatmap采用一个数据元并生成零个，一个或多个数据元 filter一组元素进来,按照某种规则,bool值为true,则被筛选出来 keyBy DataStream -&gt; KeyedStream: 逻辑地将一个流拆分成不相交的分区,每个分区包含具有相同key的元素,内部以hash的形式实现 Aggregation针对KeyedStream的每一个支流做聚合 sum min max minBy maxBy Reduce被Keys化数据流上的“滚动”Reduce。将当前数据元与最后一个Reduce的值组合并发出新值。 多流算子SplitDataStream -&gt; SplitStream:根据某些特征把一个DataStream拆分成两个或者多个DataStream SelectSplitStream -&gt; DataStream :从一个SplitStream 中获取一个或者多个DataStream Connect DataStream, DataStream -&gt; ConnectedStrems: 连接两个保持他们类型的数据流,两个数据流被Connect之后,只是被放在了一个同一个流中,内部依然保持各自的数据和形式不发生任何变化,两个流相互独立. CoMap, CoFlatMap ConnectedStreams -&gt; DataStream:作用于ConnectedStreams 上,功能与map和flatMap一样,对ConnectedStreams 中的每一个Stream分别进行map和flatMap处理 Union 和Connect作用类似,但是Connect只能合并两个stream.Union可以对两个或者两个以上的DataStream进行操作,DataStream中的数据类型需要一致. Connect和Union的区别 Union之前的两个流类型必须一样,Connect可以不一样,在之后的coMap中再去调整成为一样的 Connect只能操作两个流,Union可以操作多个 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自建博客超级好用的图片工具:PicGo]]></title>
    <url>%2F2020%2F03%2F12%2F%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%B6%85%E7%BA%A7%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7-PicGo%2F</url>
    <content type="text"><![CDATA[对个人博客来说,超级好用的图片管理工具,不容错过! 图片的困扰😫最开始写博客的时候,用的七牛云作为图床.博客里插入一张图片特别复杂,需要经历以下过程: 打开七牛云点进自己存储空间 点击上传一张图片 上传完毕后,复制该图片的链接 在博客中插入该链接 整个过程非常繁琐低效,导致我都不怎么喜欢插入图片.后来又因为我的七牛云没有域名备案没法使用,索性就一直没有加图片.最近发现了一个方便插入图片的神器,来和大家分享一下 神器:PicGo 🚀介绍:PicGo 一个用于快速上传图片并获取图片URL链接的工具, 开源免费 下载地址:PicGo 进入页面我们可以看到以下的下载选项,选择对应的操作系统下载即可 安装完成后打开软件,就可以看到以下的画面啦😉 如何使用创建自己的云储存☁我们的图片需要上传到云存储中,推荐有腾讯云, 阿里云. 这两个产品都有各自的优惠, 选择一个你自己喜欢的就可以. 我选的是腾讯云, 之前用云服务器挺好用的. 购买成功后我们进入自己的对象存储管理界面, 创建新的存储桶 创建成功后, 我们进入该存储桶, 新增一个文件夹,如image, 我们的博客图片都将放置到该文件夹下 然后点击密钥管理来生成我们的密钥 新建密钥后,我们就得到了自己的SecretId和SecretKey 好了, 在云端服务器要做的都差不多了, 然后就是看软件如何配置啦😎~ 配置PicGo打开软件, 我们来到图床设置的腾讯云COS(ps:此处根据自己的图床服务商来选择), 可以看到以下画面 说一下这几个配置: COS现基本都是v5了, 所以咱们选到v5 SecretId, SecretKey, APPID 在咱们刚才配置密钥的地方有, 复制粘贴过来 存储空间名: 就是我们存储桶的名, 可以再腾讯云对象存储-&gt;存储桶列表看到, 确认存储区也是的, 都复制过来 指定存储路径: 这个就是咱们刚才创建的那个image文件夹, 以后图片都会存到该目录下 设置为默认图床:咱就一个图床, 设置成为默认以后都会发到我的腾讯云图床上 OK, 到现在咱们的PicGo就已经配置好了, 马上开用!🤩 具体使用来到我们的上传区 我们可以把需要上传的图片拖到上传区域, 也可以点击上传按钮批量上传. 学习中我们需要很多的截图, 剪贴板图片上传就很好用了. 链接格式. 由于我们是写markdown, 就选择Markdown格式就行, 如果有别的用途也可以选择. 我们随便上传一张图片, 上传完成, Windows电脑右下角会有如下提示 ❗注意, 上传成功后, 会自动生成该图片链接的markdown语句, 我们只需要ctrl+v, 就可以复制到我们的博客中啦~真的是超级好用 进阶使用我们可以再相册页面进行图片批量的删除和复制 老是开着这个窗口, 拖照片挺麻烦的, 怎么办❓ windows下可以把窗口最小化, 功能也很丰富, 拖动照片到这个小蓝圈上就可以上传了 终极无敌好用的快捷键😆 我们在软件页面点击PicGo设置 点击修改快捷键, 我把快捷键改成了ctrl + [ , 觉得非常好用 最后好了, 现在我们可以截图 - 快捷键上传 - 快捷键粘贴, 一气合成插入图片了, 软件的作者真的太厉害了👍 希望这篇文章能对你有所帮助, 一起写博客勤积累, 做个life-long learner吧~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flink之window介绍及API]]></title>
    <url>%2F2020%2F03%2F12%2FFlink%E4%B9%8Bwindow%E4%BB%8B%E7%BB%8D%E5%8F%8AAPI%2F</url>
    <content type="text"><![CDATA[介绍window这个概念以及相关的API函数 window概念 真实的流为无界的流,如何进行处理? 可以把无限的数据流进行划分,得到有限的数据集进行处理,也就是有界流 窗口,就是将无界流切割为有界流的一种方式,它会把流数据分发到有限大小的桶中进行分析 window类型 时间窗口(Time Window) 滚动时间窗口 滑动时间窗口 会话窗口 计数窗口(Count Window) 滚动计数窗口 滑动计数窗口 滚动窗口(Tumbling Window) 将数据依据固定的窗口长度对数据进行切分 时间对齐,窗口长度固定,无重叠部分 一个数据只能划分到一个确定的窗口 滑动窗口(Sliding Window) 滑动窗口是固定窗口的更广义的一种形式,由固定的窗口长度和滑动间隔组成 窗口长度固定,可以有重叠 会话窗口(Session Window) 由一系列事件组成一个指定时间长度的timeout间隙组成,也就是一段时间没有接收到新数据就会生成新的窗口 特点:时间无对齐 window API 窗口分配器–window()方法.该方法必须在keyBy之后才能使用 更简单调用为.timeWindow和.countWindow方法,用于定义时间窗口和计数窗口 window assigner window()方法接受的输入参数是一个window assigner.它负责将输入的数据分发到正确的window中 通用的window assigner: 滚动窗口(tumbling window) 滑动窗口(sliding window) 会话窗口(session window) 全局窗口(global window) 创建不同类型的窗口 滚动时间窗口 .timeWindow(Time.seconds(15)) 滑动时间窗口 .timeWindow(Time.seconds(15), Time.seconds(5)) 会话窗口 .window(EventTimeSessionWindows.withGap(Time.minutes(10))) 滚动计数窗口 .countWindow(5) 滑动计数窗口 .countWindow(10, 2) 窗口函数(window function)定义要对窗口中收集的数据做计算操作 增量聚合函数 每条数据到来就进行计算,保持一个简单的状态 reduce aggregate 全窗口函数 先把窗口所有数据收集起来,等到计算的时候会遍历所有数据 process 其他可选API API 作用 .triger() 定义window什么时候关闭,触发计算并输出结果 .evitor() 定义移出某些数据的逻辑 .allowedLateness() 允许处理迟到的数据 .sideOutputLateData() 将迟到的数据放入侧输出流中 .getSideOutput() 获取侧输出流 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2020%2F03%2F11%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[回顾基本的排序算法 排序算法基本（做到快速无bug写出） 冒泡排序 插入排序 常考 归并排序 快速排序 拓扑排序 其他（开拓思路） 堆排序 桶排序 冒泡排序空间复杂度:O(1) 时间复杂度:O(n^2) 稳定 插入排序空间复杂度:O(1) 时间复杂度:O(n^2) 稳定 归并排序核心思想：分治 12345678910111213141516171819202122232425262728293031323334353637/** * 升序排列int数组 * @param A:需要排列的数组 * @param lo:数组起始下标 * @param hi:数组结束下标 */public static void mergeSort(int[] A, int lo, int hi){ //升序方式排列数组 //如果lo&gt;=hi,说明数组中只有一个元素，应该返回 if(lo &gt;= hi) return; //取中位数 int mid = lo + (hi-lo)/2; //左右递归两遍的数组 mergeSort(A, lo, mid); mergeSort(A, mid+1, hi); //递归结束,进行合并 merge(A, lo, mid, hi); } private static void merge(int[] nums, int lo, int mid, int hi){ //复制原来的数组 int[] cp = nums.clone(); //k表示从什么位置修改原来的数组,i是左边开始的起始位置,j是右边开始的起始位置 int k = lo, i = lo, j = mid+1; while (k &lt;= hi){ //如果左边已经放置完了,就直接放置右边剩下的 //如果右边已经放置完了,就直接放置左边剩下的 //如果左边大于右边,则放置右边,否则放置左边. if(i &gt; mid) nums[k++] = cp[j++]; else if(j &gt; hi) nums[k++] = cp[i++]; else if(cp[i] &gt; cp[j]) nums[k++] = cp[j++]; else nums[k++] = cp[i++]; } } 时间复杂度:O(nlogn) 空间复杂度:O(n) 稳定 快速排序123456789101112131415161718192021222324252627282930/** * 升序排列int数组 * @param nums:需要排列的数组 * @param lo:数组起始下标 * @param hi:数组结束下标 */public static void quickSort(int[] nums, int lo, int hi){ //如果只有一个元素了,则返回 if(lo &gt;= hi) return ; //获取参照值 int p = partition(nums, lo, hi); //把比p小的放到左边,比p大的放到右边 quickSort(nums, lo, p-1); quickSort(nums, p+1, hi);}private static int partition(int[] nums, int lo, int hi){ int tmp = nums[lo]; while (lo &lt; hi){ while (lo &lt; hi &amp;&amp; nums[hi] &gt; tmp) hi--; nums[lo] = nums[hi]; while (lo &lt; hi &amp;&amp; nums[lo] &lt; tmp) lo++; nums[hi] = nums[lo]; } nums[lo] = tmp; return lo; //返回中轴位置} 时间复杂度:O(nlogn) 空间复杂度:O(n) 稳定 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>面试复习</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习数据结构]]></title>
    <url>%2F2020%2F03%2F10%2F%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[重温数据结构，开始刷题 常用数据结构和技巧 数组、字符串 链表 栈 队列 双端队列 树 字符串字符串的处理更多的是转换成字符数组对每一个字符进行处理。 链表单链表：链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。 双链表：单链表不同的是，双链表的每个结点中都含有两个引用字段。 解题技巧： 利用快慢指针。典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。 构建一个虚假的链表头 训练技巧：在白板上画出节点之间的相互关系，画出修改的方法 栈由于历史遗留问题，Java中没有Stack接口，通过Deque接口来模拟Stack。 当我们把Deque作为Stack使用时，注意只调用push()/pop()/peek()方法，不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰。 队列 int size()：获取队列长度； boolean add(E)/boolean offer(E)：添加元素到队尾； E remove()/E poll()：获取队首元素并从队列中删除； E element()/E peek()：获取队首元素但并不从队列中删除。 添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。 throw Exception 返回false或null 添加元素到队尾 add(E e) boolean offer(E e) 取队首元素并删除 E remove() E poll() 取队首元素但不删除 E element() E peek() 双端队列特点：双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。 实现：与队列相似，我们可以利用一个双链表实现双端队列。 应用场景：双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目里都有运用。 我们来比较一下Queue和Deque出队和入队的方法： Queue Deque 添加元素到队尾 add(E e) / offer(E e) addLast(E e) / offerLast(E e) 取队首元素并删除 E remove() / E poll() E removeFirst() / E pollFirst() 取队首元素但不删除 E element() / E peek() E getFirst() / E peekFirst() 添加元素到队首 无 addFirst(E e) / offerFirst(E e) 取队尾元素并删除 无 E removeLast() / E pollLast() 取队尾元素但不删除 无 E getLast() / E peekLast() Deque是一个接口，它的实现类有ArrayDeque和LinkedList。 树在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。 重点复习一下树的遍历问题。 高级数据结构 优先队列 图 线段树 前缀树 树状数组 高级数据结构的内容过于陌生，留到后面学习整理。先巩固基础的数据结构。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>面试复习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pravega项目初试]]></title>
    <url>%2F2020%2F03%2F03%2FPravega%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一个简单的Pravega项目 Pravega中的event读取行为分别由writer &amp; reader端来实现，下面就从这两个方面来入手分析。 项目介绍一个简单的读写程序，Writer端一直等待输入，每次获得字符串后写入event。当读到”EXIT”时，写入并退出。Reader端持续读取event,每读到一个event，就把它输出并且统计其大小写出现的次数。当收到”EXIT”时，程序退出。 Writer1.一些定义12345final String scope = "mytest";final String streamName = "helloStream";final String uriString = "tcp://127.0.0.1:9090";final URI controllerURI = URI.create(uriString);final String routingKey = "helloRoutingKey"; 首先是一些string的设置，用于在后面定义scope和stream。 每一个事件都有一个Routing Key。Routing Key是开发者用于把相似的事件定位一个组的字符串。Routing Key通常由事件中产生，如“customer-id”,”machine-id” ,或者是开发者自己定义的一个字符串。Routing Key 2.创建Scope &amp; Stream123456StreamManager streamManager = StreamManager.create(controllerURI);boolean scopeIsNew = streamManager.createScope(scope);StreamConfiguration streamConfig = StreamConfiguration.builder() .scalingPolicy(ScalingPolicy.fixed(1)) .build();boolean streamIsNew = streamManager.createStream(scope, streamName, streamConfig); 创建scope和stream都需要由StreamManager来创建。首先先通过controllerURI来创建streamManager。创建scope时，创建成功则返回true，否则返回false。StreamConfiguration是用来设定stream的相关属性的，scalingPolicy(ScalingPolicy.fixed(1))就是定义stream中segment数目固定为1.创建stream时，需要scope, streamName, streamConfig三个参数，创建成功则返回true，否则返回false。 3.Write event12345678910111213141516171819try (ClientFactory clientFactory = ClientFactory.withScope(scope, controllerURI);EventStreamWriter&lt;String&gt; writer = clientFactory.createEventWriter(streamName, new JavaSerializer&lt;String&gt;(), EventWriterConfig.builder().build())) { Scanner sc = new Scanner(System.in); System.out.printf("please input:"); while (sc.hasNextLine()) { String s = sc.nextLine(); if (s.equals("EXIT")) { writer.writeEvent(routingKey, s); System.out.println("**** Exitting.."); System.exit(1); } System.out.println("*** " + s); writer.writeEvent(routingKey, s); System.out.printf("please input:"); }} writer的创建需要通过ClientFactory来实现，ClientFactory其需要scope, controllerURI这两个属性。createEventWriter创建时需要定义： 往哪个stream里写 序列化的方式，前后一致 配置属性（此处为默认属性） 写事件时，使用writer.writeEvent(routingKey, s)将event写入stream中，注意要加上Routing Key. Reader1.一些定义123456final String scope = "mytest";final String streamName = "helloStream";final String uriString = "tcp://127.0.0.1:9090";final URI controllerURI = URI.create(uriString);final String routingKey = "helloRoutingKey";final int READER_TIMEOUT_MS = 1000; 和writer一致的定义不再赘述，这里多了一个READER_TIMEOUT_MS,在后面读事件时候解释。 2.创建ReaderGroup12345678final String readerGroup = "helloReaderGroup";final ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder() .stream(Stream.of(scope, streamName)) .build();try(ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scope, controllerURI)){ readerGroupManager.createReaderGroup(readerGroup, readerGroupConfig);} reader group通过ReaderGroupConfig, ReaderGroupManager来创建。 3.Read event123456789101112131415161718192021222324252627282930313233343536373839try(ClientFactory clientFactory = ClientFactory.withScope(scope, controllerURI); EventStreamReader&lt;String&gt; reader = clientFactory.createReader("myreader",readerGroup, new JavaSerializer&lt;String&gt;(),ReaderConfig.builder().build())){ EventRead&lt;String&gt; event = null; System.out.println("Reader is ready."); while(true){ try{ event = reader.readNextEvent(READER_TIMEOUT_MS); if(event.getEvent() != null){ String res = event.getEvent(); if(res.equals("EXIT")) break; int[] upperCase = new int[26]; int[] lowerCase = new int[26]; for(int i=0; i&lt;res.length(); i++){ char c = res.charAt(i); if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') lowerCase[c-'a']++; else if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') upperCase[c-'A']++; } System.out.println("Read event: " + res); for(int i=0; i&lt;26; i++) { if(lowerCase[i] != 0){ System.out.printf("%c:%d ", 'a'+i, lowerCase[i]); lowerCase[i] = 0; } } for(int i=0; i&lt;26; i++) { if(upperCase[i] != 0){ System.out.printf("%c:%d ", 'A'+i, upperCase[i]); upperCase[i] = 0; } } System.out.println(); } } catch(ReinitializationRequiredException e){ e.printStackTrace(); } }} reader的创建，需要通过ClientFactory，创建时候需要定义： reader的名字 reader所属的reader group 反序列化的方式 配置属性（此处为默认属性） 读事件的时候，由reader.readNextEvent(READER_TIMEOUT_MS)来读取事件，此处的READER_TIMEOUT_MS就是我们在1中所定义的。如果当前没有event了，将会阻止等待事件的继续到来，READER_TIMEOUT_MS就是等待事件的上限。 当没有事件到来，event.getEvent()的值就是null，否则就是指向通过反序列化得到的实例。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Pravega</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库:事务概念]]></title>
    <url>%2F2020%2F02%2F29%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[介绍数据库中事务这个概念 之前遇到过事务这个概念，在做pravega的时候有个名词叫做trasaction，英语不太懂，查了之后发现原来就是事务的意思，顺便再学习一下到底什么是“事务”。内容整理自百度百科 1.定义数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 2.理解对于数据库，我们进行的操作无非就是CRUA，事务是工作的离散单位。在单用户、单数据库下执行事务比较简单，但在分布式环境下，维护多个数据库的完整性就比较复杂。一个事务再多个场地进行修改，那就需要管理机制来防止数据重写并提供同步。另外还需要具有返回失效事务的能力，提供安全保障和提供数据恢复能力。 比如，我们去银行转账，操作可以分为下面两个环节： 从第一个账户划出款项。 将款项存入第二个账户。 在这个过程中，两个环节是关联的。第一个账户划出款项必须保证正确的存入第二个账户，如果第二个环节没有完成，整个的过程都应该取消，否则就会发生丢失款项的问题。整个交易过程，可以看作是一个事物，成功则全部成功，失败则需要全部撤消，这样可以避免当操作的中间环节出现问题时，产生数据不一致的问题。 我们可以这样理解数据库事物:对数据库所做的一系列修改，在修改过程中，暂时不写入数据库，而是缓存起来，用户在自己的终端可以预览变化，直到全部修改完成，并经过检查确认无误后，一次性提交并写入数据库，在提交之前，必要的话所做的修改都可以取消。提交之后，就不能撤销，提交成功后其他用户才可以通过查询浏览数据的变化。 3.性质（ACID） 原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。 一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致。 夺隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。 夺持久性(Durability):对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 百度给的这个一致性的解释看的我很懵逼啊，于是又查询了相关资料，数据库中一致性准确定义为： Consistency ensures that a transaction can only bring the database from one valid state to another, maintaining database invariants: any data written to the database must be valid according to all defined rules, including constraints,cascades,triggers, and any combination thereof. 一致性确保事务只能把数据库从一个有效的状态带到另一个有效的状态，保持数据库的不变性:任何写入到数据库的数据都需要按照已经定义的规则为有效的，包括约束、级联、除法器及其任意组合。 举一个例子，一个银行系统，内部在进行转账的过程中，金钱总量保持不变是其定义的规则。那么A转了100给B，就必须A-100,B+100，使其金钱总量不变，处于一个有效的状态。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2020%2F02%2F18%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录Linux学习过程中学到的命令与用法 Linux学习笔记文件和目录管理文件类型 - 普通文件 d 目录 b 块设备文件，保存大块数据的设备，如硬盘 c 字符设备文件，如键盘鼠标 s 套接字文件，用于网络数据连接 p 管道文件，作用是解决多个程序同时存取一个文件所造成的错误 l 链接文件，软链接 cd 切换目录 ~ 当前登录用户主目录 ~用户名 切换到指定用户的主目录 上次所在的目录 . 当前目录 .. 上一级目录 / 根目录 pwd 显示当前工作路径（常用）ls 查看目录中的文件 ls [选项] 目录名称 常用选项 -a 显示全部的文件，包括隐藏文件（开头为 . 的文件）也一起罗列出来，这是最常用的选项之一。 -A 显示全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录。 -l 使用长格式列出文件和目录信息。 -h 以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。 -R 连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。 mkdir 创建目录 -p 选项递归建立目录。 如：mkdir -p lm/movie/jp/cangls -m 选项自定义目录权限。 如：mkdir -m 711 test2 rmdir 删除目录 也可以用-p选项递归删除，但是只能删除空目录，作用非常小，顾不常用 touch 创建文件ln 文件之间建立软/硬链接 ln [选项] 源文件 目标文件 -s：建立软链接文件。如果不加 “-s” 选项，则建立硬链接文件； -f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件； cp 复制文件和目录 cp [选项] 源文件 目标文件 常用选项 -r：递归复制，用于复制目录； -a：相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍； -p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；目的：我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。 -i：询问，如果目标文件已经存在，则会询问是否覆盖； -d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接； -l：把目标文件建立为源文件的硬链接文件，而不是复制源文件 -s：把目标文件建立为源文件的软链接文件，而不是复制源文件 分支主题 2分支主题 3XMind: ZEN - Trial Version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下C程序获得shell脚本输出]]></title>
    <url>%2F2020%2F02%2F17%2FLinux%E4%B8%8BC%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%BE%97shell%E8%84%9A%E6%9C%AC%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[shell脚本输出结果重定向 课设里面，需要查看系统的相关信息。指导书上直接打开文件来获得，但我发现通过terminal中的一些命令更容易获得自己想要的信息，于是就研究如何把终端中输出的结果重定向过来。 使用popen 1FILE *popen(const char *command, const char *type); 该函数的作用是创建一个管道，fork一个进程，然后执行shell，而shell的输出可以采用读取文件的方式获得。采用这种方法，既避免了创建临时文件，又不受输出字符数的限制。 123#include &lt;stdio.h&gt; //头文件FILE *popen(const char *command, const char *type);int pclose(FILE *stream); popen 通过type是r还是w确定command的输入/输出方向，r和w是相对command的管道而言的。r表示command从管道中读入，w表示 command通过管道输出到它的stdout，popen返回FIFO管道的文件流指针。pclose则用于使用结束后关闭这个指针。 下面看一个示例，将free -m命令输出情况重定向输出到buf中，方便处理。 1234567891011121314151617181920#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;int main( void ) { FILE *stream; char buf[1024]; memset( buf, '\0', sizeof(buf) ); stream = popen( "free -m", "r" ); fread( buf, sizeof(char), sizeof(buf), stream); printf("%s\n", buf); pclose( stream ); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux重装后必做!]]></title>
    <url>%2F2020%2F02%2F16%2FLinux%E9%87%8D%E8%A3%85%E5%90%8E%E5%BF%85%E5%81%9A%2F</url>
    <content type="text"><![CDATA[最近重装好几次Ubuntu了，每次重装后都有些准备工作要做，老是得上网查，这里记录一下所有步骤。 1. 安装openssh-service安装这个是为了用Xshell等连接工具连接到我们的虚拟机，使用终端界面。因为VM虚拟机里无法把主机的内容复制粘贴进去，装了VM Tools才行，所以现在用连接工具比较多。使用下面的命令安装openssh-service： 1sudo apt-get install openssh-server 安装完毕后，查看本机的ip，之后就可以通过连接工具登录啦。 2. 修改镜像源ubuntu默认使用的是外国的镜像源，下载速度巨慢无比，务必换成国内镜像源。我通常使用的是阿里的镜像源，使用其他的也可。 首先先备份本地的源文件，位置在/etc/apt/sources.list 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bk 然后用vim打开，源文件，将国内镜像粘贴进去。 1sudo vi /etc/apt/sources.list Ubuntu 18.04 LTS 阿里云镜像 123456789101112131415# https://opsx.alibaba.com/mirrordeb https://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse # 仿照清华镜像源，注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释# deb-src https://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # deb-src https://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 最后更新列表 12sudo apt-get updatesudo apt-get upgrade 3. 安装vimUbuntu不知道为什么，默认安装的vim是个残次品，用起来相当难受，所以安装一下完整版的vim。 1sudo apt install vim 4. 息屏123456关闭息屏，最后0是代表关闭锁屏，将0替换为60代表60s后自动息屏，以此类推。gsettings set org.gnome.desktop.session idle-delay 0 关闭锁屏gsettings set org.gnome.desktop.screensaver lock-enabled false 5. gcc1sudo apt install gcc document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xshell中显示用户名和主机颜色]]></title>
    <url>%2F2020%2F02%2F15%2FXShell%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E4%B8%BB%E6%9C%BA%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[最近开始用Xshell连接虚拟机，虽然Xshell可以更改配色方案，终端中默认不显示用户名和主机名的颜色，命令一多，非常难以辨认。于是记录一下如何使用户名和主机名显色。 修改用户目录下的.bashrc文件 通过vi打开该文件，vi ~/.bashrc 在文件稍微靠后的位置找到这么一句话，# force_color_prompt=yes , 把注释注销掉，保存退出 加载文件。source ~/.bashrc 然后就可以看到Xshell终端中用户名和主机名颜色变成主题对应的颜色了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim简单入门]]></title>
    <url>%2F2020%2F02%2F12%2Fvim%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[vim快速上手了一下，记忆一些简单的指令和操作 1.移动光标h j k l 上：k 下：j 左：h 右：l 2.模式普通模式和插入模式 敲击按键 含义 i 在光标前进入插入模式 I 在光标所在行的行首进入插入模式 a 在光标的后边进入插入模式 A 在光标所在行的行尾进入插入模式 o 在光标所在行的下方插入空行并进入插入模式 O 在光标所在行的上方插入空行并进入插入模式 s 删除光标指定的字符并进入插入模式 S 将光标所在行清楚并进入插入模式 3.删除命令普通模式下，删除单一字符可以使用x命令，删除更多字符可以使用d命令 motion–表示操作范围的指令 按键 含义 0 将光标定位到行首的位置 ^ 同上 $ 将光标定位到行尾的位置 b 将光标定位到光标所在单词的起始处 e 将光标定位到光标所在单词的结尾处 w 将光标定位到下一个单词的起始处 gg 将光标定位到文件的开头 G 将光标定位到文件的末尾 -d motion可以组成更多的删除命令 按键 含义 d0 删除光标从当前位置（不包含）到该行行首的所有字符 d^ 同上 d$ 删除从光标当前位置（包含）到该行行尾的所有字符 db 删除从光标当前位置（不包含）到该单词起始处的所有字符 de 删除从光标当前位置（包含）到单词结尾处的所有字符 dw 删除从光标当前位置（包含）到下一个单词起始处的所有字符 dh 删除光标前边一个字符 dl 删除光标制定的字符 dj 删除光标所在行以及下一行的所有字符 dk 删除光标所在行以及上一行的所有字符 dd 删除光标所在行的字符 dgg 删除光标所在行到文件开头的所有字符 dG 删除光标所在行到文件末尾的所有字符 数字 + motion = 重复多个motion d + 数字 + motion = 删除多个motion范围 4.撤销 u表示撤销最后一次修改 U表示撤销对整行的修改 ctrl + r 可以恢复撤销的内容 5.粘贴 按键 含义 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) 命令c = 命令d + 进入删除模式 6.查看文件信息 按键 含义 ctrl + g 在底栏显示文件信息 行号+G / :行号 跳转到该行 % 找到另一半括号 &lt;&lt; / &gt;&gt; 左右缩进 7.搜索 /目标 ?目标 搜索方向 从光标开始向后 从光标开始向前 n 向后搜索下一个 向前搜索下一个 N 向前搜索下一个 向后搜索下一个 十个特殊字符需加转义符’\‘进行搜索：. * [ ] ^ % / ? ~ $ 8.文件操作 按键 含义 :w filename 文件另存为 :r filename 将别的文件合并到该文件中 vi -o 或 -O 打开多个文件，小写竖向排列，大写横向排列 ctrl + ww 打开多个文件时进行切换窗口 9.显示行号在当前文件输入命令 :set nu，即显示行号，:set nonu则为取消。该方法只为临时显示行号，下次打开时同样没有。 永久显示行号 在命令行输入vim ~/.vimrc ，即进入配置文件vimrc中，加入set nu， 保存退出，就可永久显示行号 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电话面记录与心得]]></title>
    <url>%2F2019%2F12%2F16%2F%E7%94%B5%E8%AF%9D%E9%9D%A2%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[第一次小的电话面，紧张到不行，很有收获。 1.面试记录 刚上来就问我，觉得学的比较好的课程有哪些。有点懵逼，好像没有什么学的特别好的课程啊，就只能往专业课这边靠，说算法与数据结构还行（才70+分，菜…），还说了个刚学的计算机网络。然后刘哥就就着算法与数据结构开问了，心里慌得一批。先问了最简单的排序问题，这个真的看过很多遍，但有些算法比如快排，堆排，没有真正的理解。第一个问题是什么时候快排的效率会低于冒泡，这个之前洛谷做题遇到过，就答得从容。第二个问题是给一个数组，里面有奇数偶数，设计一种算法将奇数放到队列前面，偶数放到队列后面。一听到这个题目我的第一反应就是用两个队列，作为奇偶数的存放区域，然后遍历一遍，分别入队，再合并就行了。然后刘哥问我还有别的思路没，我就卡住了……他提示说用快排的思路，我倒是知道快排可以这么做，就是有点说不清楚，就不太敢说。再进一步他就问快排会使得队列不稳定，设计一种算法使得最后队列依然稳定。这个我确实想不出来，他让我别那么急着放弃orz。不过他后来说的算法我感觉也有问题啊QAQ ​ 数据结构问完后，就问了一下计网的东西。第一个问题问的是什么为了实现负载均衡与高可用性，应该在哪一层怎么怎么样。这个8知道，就直说了，也没有做过web应用，不了解啊。然后就问了个很基础的ping是在哪一层，用的什么协议。啊，当时真的脑子卡壳了，也真的有点忘了Ping的具体用法，就说不太清楚。他说ICMP，我就突然想起来了。害，还是基础知识有些不够啊。 ​ 因为之前电话聊的时候，我有跟他说现在在实验室做的ceph项目（虽然我都还没实际参与到其中……），然后他就问除了这个还有什么竞赛项目经历吗。本来我说的没有，突然想起来暑假做的爬虫工作，然后就提起这个了（我为什么要提。。），就悲催了。本来想着是显示有更多经历的，但真的，我这些经历都没做到什么实际工作，也只是别人安排我做什么我就去做，没有主观能动性，所以当他问一些项目背景啊什么的，我真的都不太知道。看我答得这么混乱，他就让我一句话总结一下项目背景与意义、以及我在其中做的工作。强行总结了一通，越说越心虚。刘哥也对我的情况评价了一下，这个放到心得处讲。 ​ 电话面情况差不多就是这样了，本来以为只是一个简单的外包工作，没想到还会有这么多事。不过这个也很正常，别人不可能完全不了解你，就把工作交给你了。也发现了自己现在欠缺的东西还很多，加油学啊。 2. 面试心得 算法与数据结构继续深度学习。这个真的是不管学哪门语言，用什么技术，都躲不开的话题。今天问的问题都这么简单我答得还那么烂，这方面的技术积累真的不行。算法方面，今年这门算法课我也感觉自己这个地方学的很不行，动态规划啊，分治啊什么的，理解不到位，代码也不会写，有时间一定要学起来。 总结你的项目经历！之前看羊哥讲面试的视频，里面说那些自己不熟的项目千万不要写在简历上，要写就写那些你最熟悉，最能体现你技术水平的项目。听的时候不以为意，轮到自己面试的时候才发现真的是这样的。对项目不了解，也没做什么具体贡献，只会让你的回答非常糟糕。刘哥也给出了具体的建议：不管做什么项目，只要参与其中了，就一定要明确项目需求，思考这个项目为什么成立。只有明确项目背景后，明白其architecture，才能发挥自己的主观能动性，在项目中做出更多的贡献，能更好地提高自己，建立自己的reputation。 大三上都快要过完了，不能在这么混下去了。要逐步建立自己的技术栈，总结自己的项目经历，不然找工作的话简历都写个 🔨 啊。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近的编程感悟]]></title>
    <url>%2F2019%2F12%2F03%2F%E6%9C%80%E8%BF%91%E7%9A%84%E7%BC%96%E7%A8%8B%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[近日编程小感 伤病归来，接连的实验，忙于应付，感觉有些疲惫。不过从最近的poj实验和计网实验，也有一些编程的小感悟，随手记一下。 编程是个手艺活 伤病了大概一个多星期吧，这期间基本就没有写过代码。住院的时候确实有疼到没办法写，但没什么大碍的时候我都在那儿玩游戏。所以伤好归来，开始写代码了，感觉自己特别生疏，简单的c++代码差点不知道怎么开头写了。 虽然这是个很小的事情，但我觉得还是很有警示作用。本来自己的代码量就不是很够，平时在一疏忽，写的代码就少之又少。而写代码本身就是一个手艺活，写的越多，思考的越多，才能写的更好。还是得继续加油啊。 思考 &gt;&gt; 写代码 以前数据结构老师说，写代码重要的是把思路搞清楚，思路理顺了，代码实现起来就是轻而易举的事。之前我没有明白这句话的意义，在第二次计网实验彻底懂了。 这次实验的一开始，我也像之前写代码一样，感觉对算法理解的差不多，在脑海里大概推演一下，是那么回事，就开始敲代码了。然而，我越写代码，就越感觉思维的混乱。一段代码写了又删，不停的对算法有新的认识，不停地推翻之前写的错误版本。到最后觉得不停的改实在太累了，就把原来写的全部推到重来，实现起来却很快，思路异常清晰，逻辑严谨。后来仔细想一下，我省在思考算法上的时间，最后还是一点都没省下来。 有了这次教训，在后面实现SR协议的时候，我花了一个多小时来认真思考这个算法，详细考虑每一个步骤该怎么处理，设计与之相匹配的数据结构。最后落实到代码实现上，真的感觉就是把我写在纸上的那些东西变成了代码而已，相当轻快。 学习中，勤思，否则将成为代码的搬运工。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程感悟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用命令行查询电池损耗]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%94%B5%E6%B1%A0%E6%8D%9F%E8%80%97%2F</url>
    <content type="text"><![CDATA[xps13电池损耗严重，windows下在cmd中可以很方便的查询电池现况，用过很多次了，记录一下。 以管理员身份运行cmd 输入命令：powercfg /batteryreport /output "C:\battery_report.html" 上面这段命令会生成一个电池报告，路径就在上面，该路径也可以自己定制。前往该路径打开html文件即可查看电池现况。 用了两年的xps13，之前电池还挺耐用的，一般去图书馆都不用带充电器，现在不得不带上了。用电池30min掉了20%，真的难顶啊，实在不行就只能去换一块电池了 😭 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>电脑使用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++知识点清单]]></title>
    <url>%2F2019%2F10%2F18%2FC-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[C++不熟悉知识点学习记录 TOLEARN List 访问限制 虚函数、友元函数、析构函数 运算符重载 多重继承 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP:字符画 总结]]></title>
    <url>%2F2019%2F10%2F16%2FCSP-%E5%AD%97%E7%AC%A6%E7%94%BB-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[考试时候毫无头绪，平时自己静下心来写还花了两三个小时，CSP真的不简单啊。现在来总结总结这个题，看看到底是哪里难到了我。 吐槽 题目解释的时候，用正常的序列在那儿解释，到了题目输出的时候，直接变成了ASCII码，人都给我看傻了。主要是没有ASCII码对照表，当时人一懵，就看不懂他写的啥意思了。然后题目中的48，ASCII中竟然是把4和8分开输出的，当时就找了好半天，感觉这输出和题目说的对不上呢。 题目中讲了38来修改字的颜色，48来修改背景的颜色，讲了一大堆，到了后面发现只用修改背景颜色。害，废话真多。 原来题目长的原因就是因为废话太多。 总之，我太菜了😵 思路 ​ 其实如果冷静读题，能把题目中那么多废话刨开，然后把ASCII码和结果对应搞明白，这个题并不是很难的。总的流程无非就是输入所有的RGB配色，然后通过分块的方式进行每一块RGB计算（感觉当时写数独对分块操作颇有心得）。然后再是按照分块的顺序，通过双循环来输出就行了。 zz错误以及一些重要的坑！ 最最重要的一个错误 : 在输出反斜杠(\) 时，没有采用忘记需要通过转义序列来输出，导致最开始无法输出结果。也是懵逼了好久才发现这个错误。与此相类似的是输出单引号(‘)和双引号(“)时也需要转义序列，以后要注意。 在处理RGB到字符串的时候，开始是分号的位置放置的不合适。后来是发现对单个颜色值的每一位，我前面都加了一个分号，这样是不对的，应该只用在最高位前面加一个分号即可，感觉当时写糊涂了。 每一行的末尾开始的时候忘记判断是否需要重置。重置之后发现自己又多加了一个空格，导致出错。 重要tips:写程序的时候，尤其这种题目长，比较复杂的模拟题，理清题目很重要。用草稿纸和画图的方式来加快自己的理解。并且尽量把自己处理的步骤以及边界条件罗列下来，防止自己脑抽。在coding的过程中，最好还是多写一点注释，这样能提醒自己，我现在做到哪一步了，可以更加明确处理的思路，然后也能提醒自己当时写的对应位置的特殊情况。也方便自己出错的时候回来检查。 申明全局变量：在程序中，那种放置大量元素的结构，尽量声明为全局变量，大小可以根据题目提示的数据范围，选择最大的即可。之前我一直觉得，一开始就声明一个那么大的何必呢，根据题目的输入来声明对应大小不久可以了，然鹅这道题让我意识到了全局变量的重要性。因为全局变量存储在自由分配区，而局部变量存储在栈区。按照室友的说法，一般这种考试，你声明的全局变量基本都装得下，但是如果你声明的是局部变量，那么栈的空间是有限的，运行的时候就可能出现栈满这种情况，导致运行错误。所以还是尽管使用全局变量吧。 说点没用的 ​ CSP这段时间刷了一些第三题/第四题，一方面感觉CSP确实挺难的，但另一方面也发现自己还是有能力做出来这些题的。经过这段时间的练习，感觉做题能力有了一点提高，对C++做题的使用也更熟练了。所以继续加油吧！后面做题尽量自己写一些测试用例，毕竟考试的时候没办法提交看到你跑出来的结果呀。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++之list]]></title>
    <url>%2F2019%2F10%2F15%2FC-%E4%B9%8Blist%2F</url>
    <content type="text"><![CDATA[记录C++中list的用法 list的实现list是 每个节点包含前继节点，后继节点，数据域三部分的双向循环链表。和普通链表性质一样，不提供随机访问，访问时间复杂度为0(n)，适合插入和删除。 头文件#include&lt;list&gt; list包含的函数1.声明list list list1; // 声明一个空的list1 list list3 (list2.begin(), list2.end()); // 用list2的迭代器内容声明list3 list list4 (list3); // 声明list4为list3的一个副本 list1.~list(); // 注销list 2.访问元素 list.front(); //返回第一个元素的值 list.back(); //返回最后一个元素的值 list.begin(); //返回第一个元素的迭代器 list.end(); //返回最后一个元素的迭代器 遍历 123456list&lt;int&gt; a;list&lt;int&gt;::iterator iter = a.begin();//或者 auto iter = a.begin();while(iter!=a.end()){ cout&lt;&lt; *iter++ &lt;&lt;endl;} 3.添加、删除元素 list.pop_front(); //删除第一个元素 list.pop_back(); //删除最后一个元素 list.clear(); //清空list list.insert(iter, t); //在iter之前插入元素t list.erase(iter, t); //删除iter处的元素 如何控制iter位置： 123auto iter = a.begin();srd::advance(iter, 10); //将iter往后移10位a.erase(iter); //此时删除的就是第十一个元素 4.排序 list.sort(); //默认升序排序 list.reverse(); //将list元素反转 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>解题记录</category>
      </categories>
      <tags>
        <tag>C++, list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[printf与十六进制]]></title>
    <url>%2F2019%2F10%2F06%2Fprintf%E4%B8%8E%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[如何用printf输出十六进制 CSP里面用到十六进制的地方还是挺多的，所以记录一下如何输出十六进制数据。 12345int a = 0xf;printf("%x\n", a); //x为小写时，输出a~fprintf("%X\n", a); //注意这里的X为大写，输出时A~F为大写printf("%4x\n", a); //补齐为4位，左边补空格printf("%04x\n", a); //补齐为4位，左边补0 结果 1234fF f000f document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高效率:cin和cout]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87-cin%E5%92%8Ccout%2F</url>
    <content type="text"><![CDATA[做题还是少用cin/cout,转用scanf/printf吧 今天做CSP：190303_RAID5这个题的时候，第一版做完结果30分，运行超时。费劲心思优化之后，还是一样的结果。不知道怎么优化后，去网上查别人的解法。看别人代码的时候主意到了这么一句话 1std::ios::sync_with_stdio(false);//避免c++中cin操作超时。 觉得可能跟这个原因有关，于是在代码中加上了上面这句话，于是就AC了…小伙感觉非常震惊，于是去网上了解详情。 博客解释 cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几，还有应注意的是scanf与printf使用的头文件应是stdio.h而不是iostream。 sync_with_stdio函数是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将输出流绑到了一起。 所以以后要是大型输入输出时候，采用cin/cout还是需要加上这句话来提速。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的用法:记一道LeetCode题目]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%A0%88%E7%9A%84%E7%94%A8%E6%B3%95-%E8%AE%B0%E4%B8%80%E9%81%93LeetCode%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[周赛中遇到的一道活用栈的题目，比较有启发意义。 题目 5206. 删除字符串中的所有相邻重复项 题目描述 给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。在执行完所有删除操作后，返回最终得到的字符串。本题答案保证唯一。 示例 输入：s = “deeedbbcccbdaa”, k = 3输出：”aa”解释： 先删除 “eee” 和 “ccc”，得到 “ddbbbdaa”再删除 “bbb”，得到 “dddaa”最后删除 “ddd”，得到 “aa” 数据结构：栈 解法：将字符串的每个字符按照顺序依次进站，如果栈中已经有k个相同的字符，就将他们依次弹出。最后将栈中剩余的字符串按照反序连接起来输出即得到正确答案。 启发：之前学了数据结构，但是感觉自己并没有用到解题中，没有这种思考的意识。本来自己在想怎么解的时候，一直在思考如何对字符串进行操作，听到别人解析用栈来实现的时候，觉得恍然大悟。所以还是数据结构基础要打好，然后就是如何灵活应用这些数据结构来解决问题。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041import javafx.util.Pair;import java.util.Stack;class Solution { public String removeDuplicates(String s, int k) { /** *Pair用来记录当前字符以及这个字符是第几个了 */ Stack&lt;Pair&lt;Character, Integer&gt;&gt; stack = new Stack&lt;&gt;(); Pair&lt;Character, Integer&gt; pair = new Pair&lt;Character, Integer&gt;(s.charAt(0), 1); stack.push(pair); int len = s.length(); for(int i=1; i&lt;len; i++){ if(!stack.isEmpty()){ char temp = stack.peek().getKey(); int num = stack.peek().getValue(); if(temp == s.charAt(i)){ stack.push(new Pair&lt;&gt;(temp, num+1)); if(num+1 == k){ for(int a = 0; a&lt;k; a++) { stack.pop(); } } } else{ stack.push(new Pair&lt;&gt;(s.charAt(i), 1)); } } else { stack.push(new Pair&lt;&gt;(s.charAt(i), 1)); } } String ans = ""; while (!stack.isEmpty()){ char a = stack.peek().getKey(); ans = a + ans; stack.pop(); } return ans; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>栈, Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)C++中struct和class的区别]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%BD%AC-C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[初学C++，对struct的用法感觉非常奇怪，和C中差别挺大。看到一篇博客写的挺好，转载一下。 原博客地址：C++中struct和class的区别 1）默认的继承访问权限。struct是public的，class是private的。 如果不知道什么是public继承，什么是private继承的，可以去查书，这里暂不讨论。 你可以写如下的代码： 123456789struct A{char a;}；struct B : A{char b;}； 这个时候B是public继承A的。如果都将上面的struct改成class，那么B是private继承A的。这就是默认的继承访问权限。所以我们在平时写类继承的时候，通常会这样写： 1struct B : public A 就是为了指明是public继承，而不是用默认的private继承。 当然，到底默认是public继承还是private继承，取决于子类而不是基类。我的意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。如下： 12345struct A{}；class B : A{}; //private继承struct C : B{}； //public继承 2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。 注意我上面的用词，我依 旧强调struct是一种数据结构的实现体，虽然它是可以像class一样的用。我依旧将struct里的变量叫数据，class内的变量叫成员，虽然它 们并无区别。其实，到底是用struct还是class，完全看个人的喜好，你可以将你程序里所有的class全部替换成struct，它依旧可以很正常 的运行。但我给出的最好建议，还是：当你觉得你要做的更像是一种数据结构的话，那么用struct，如果你要做的更像是一种对象的话，那么用class。 当然，我在这里还要强调一点的就是，对于访问控制，应该在程序里明确的指出，而不是依靠默认，这是一个良好的习惯，也让你的代码更具可读性。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swing的一些使用技巧]]></title>
    <url>%2F2019%2F09%2F25%2FSwing%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[记录一些Swing做GUI时候的一些技巧 窗体居中设置 1this.setLocationRelativeTo(null);//窗体居中显示 窗口自适应大小用Java代码先获得屏幕大小，然后在设置宽高。获得屏幕大小代码如下 123Dimension screen=Toolkit.getDefaultToolkit().getScreenSize();//得到屏幕的大小System.out.println (screen.getWidth());//输出屏幕的宽度System.out.println (screen.getHeight());//输出屏幕的高度 然后可以设置相应的bounds的比例 String使用的一个小经验下午在做判断两个字符串是否相等的时候，我用了==来进行判断，但一直会出错，当时一直不明白为什么。旁边的同学提醒我看idea的提示，让我改用equals()来判断，改完后就正确了。我就突然明白，两个字符串常量比较时候可以用==，因为他们判断时是判断他们是否指向同一个字符串。equals()是来判断两个字符串是否相等。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Swing, Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC学习笔记]]></title>
    <url>%2F2019%2F09%2F11%2FJDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录JDBC使用方法 什么是JDBCJDBC, Java Database Connecive, Java 数据库连接，是一组专门负责连接并操作数据库的标准，在整个JDBC中实际上大量的提供的是接口。针对于各个不同的数据库生产商 ，只要想使用JAVA 进行数据库的开发，则对这些标准有所支持。 JDBC操作步骤 加载数据库驱动程序 连接数据库，通过Connection 接口和 DriverManager 类完成 操作数据库，通过Statement、PreparedStatement、ResultSet 三个接口完成 关闭数据库 加载数据库我使用的是mysql连接，需要将mysql-connector-java-8.0.17.jar（我使用的是这个版本）这个包导入到项目之中。IDEA导入方法是，File -&gt; project structre -&gt; 左边选择Modules -&gt; 在这个包管理界面，点击右侧的➕ -&gt; 通过你的包的路径，选择这个jar包即可导入。 连接数据库123456789101112131415public class Demo { public static void main(String[] args) { try { //加载驱动类 Class.forName("com.mysql.cj.jdbc.Driver"); //建立连接(连接对象内部其实包含了Socket对象，是一个远程连接。比较耗时！) //真正开发中，为了提高效率，都会使用连接池来管理连接对象。 Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC", "user","password"); System.out.println(con); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); } }} 连接的时候遇到了几个问题。 1.报错：Loading class com.mysql.jdbc.Driver. This is deprecated. The new driver class is com.mysql.cj.jdb这个问题是因为高版本的驱动，连接class有所修改，forname()里面需要写“com.mysql.cj.jdbc.Driver” 而不是”com.mysql.jdbc.Driver” 2.报错：SQLException: The server time zone value ‘�й���׼ʱ��’ is unrecognized在配置datasource.url时出现了时区不一致的问题，在后面加上“?serverTimezone=UTC”即可 3.这里有两个异常操作，Java基础不是很好，暂时无法理解为什么这么写，先记住就好。 操作数据库Statement接口1234567891011121314151617181920public class Demo1 { public static void main(String[] args) { try { //加载驱动类 Class.forName("com.mysql.cj.jdbc.Driver"); //建立连接 Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC", "user","password"); Statement stmt = con.createStatement(); String sql = " INSERT INTO tb_courses" + " (course_id,course_name,course_grade,course_info)" + " VALUES(2,'Network',3,'Computer Network');"; stmt.execute(sql); //SQL注入 } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); } }} 建立连接和前面时一致的。主要是中间的执行有所区别。 Statement是通过一个String来存储所要进行的sql操作，然后通过execute()方法来实现要进行的操作。存储的sql操作支持字符串拼接，可以将values的值拼接成一句sql语句。 这种可拼接的方法就带来了一个问题，叫做SQL注入。什么是SQL注入，也就是说，你在拼接的过程中是没有进行字符串检查的，万一在某个where语句后面拼接时，出现了判断结果与你预期的不一致，最后导致数据库内容出错，甚至删库的情况出现。视频讲解并不推荐这种方法。 PreparedStatement接口12345678910111213141516171819202122232425262728public class Demo2 { public static void main(String[] args) { try { //加载驱动类 Class.forName("com.mysql.cj.jdbc.Driver"); //建立连接(连接对象内部其实包含了Socket对象，是一个远程连接。比较耗时！) Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/test_db?serverTimezone=UTC", "user","password"); String sql = "INSERT into tb_courses (course_name, course_grade) values(?,?)"; //?占位符 PreparedStatement ps = con.prepareCall(sql); //传参方法1// ps.setString(1, "JDBClearning");// ps.setFloat(2, 6.0f); //传参方法2 ps.setObject(1, "JDBC"); ps.setObject(2, 12); System.out.println("插入正在学习JDBC"); ps.execute(); } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); } }} PreparedStatement作为Statement的子类，可以使用预编译，然后传参的方法，来实现sql语句。符号”?”作为占位符，为后面传参做准备。传参一共有两种方法可以使用。 一种是明确传参类型。比如传参是String类型，就用setString()方法来传参。第一个参数是表示位置信息，第二个是你要插入的数据。插入int就用setInt()方法，其他的类似。另一种是不明确传参类型。使用setObject()方法传所有参数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当我在学MySQL时我到底在学什么]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%BD%93%E6%88%91%E5%9C%A8%E5%AD%A6MySQL%E6%97%B6%E6%88%91%E5%88%B0%E5%BA%95%E5%9C%A8%E5%AD%A6%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[一点MySQL学习感想 因为软工大作业项目的缘故，所以最近自己在学习如何使用MySQL数据库。学了有几天了，都是在学习命令行下的一些操作，给我的直接感受和当时使用navicat的感觉差不多，觉得好像就是把图形化界面使用命令行来表示了而已啊。找来一篇SQL语言教程，发现其实二者是互通的嘛。那么问题来了，当我在学MySQL时我到底在学什么呢？ 在知乎上翻看跟数据库有关的话题，如何回答这个问题心中慢慢有了眉目。回顾这几天的学习，说白了就是学习如何使用这种数据库，而数据库的主要功能无非就是存储和查询。学习数据库不是目的，它只是做开发时必须要用到的工具。对于当时做爬虫项目而言，数据库更可以是发掘数据中潜藏价值的仓库。 所以先学好怎么使用，有兴趣再去深入研究数据库原理等相关知识吧。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记]]></title>
    <url>%2F2019%2F09%2F07%2Fmysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MySQL学习记录 MySQL安装这个部分在暑假实习时候已经安装成功，就没有多花时间在这个上面。但为什么当时没有学习使用MySQL呢….当时用了navicat图形化管理，到后来不还是得学，哎…. MySQL数据库相关操作创建在MySQL中，使用create database语句创建数据库，语法格式如下： CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt; [[DEFAULT] CHARACTER SET &lt;字符集名&gt;] [[DEFAULT] COLLATE &lt;校对规则名&gt;];语法说明： IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。 [DEFAULT] CHARACTER SET：指定数据库的默认字符集。 [DEFAULT] COLLATE：指定字符集的默认校对规则。 实例1 输入create database test_db语句， 即可创建一个名为test_db的数据库 实例2 创建一个数据库，名为test_db_char，默认字符集为utf8，默认校对规则为utf8_general_ci mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_chinese_ci; Query OK, 1 row affected (0.03 sec)查看show databases语句，可以查看所有用户范围内的数据库该语句可以加上后缀like, 用于匹配数据库名称, 后面所借数据库名需用’ ‘括起来。 实例 show databases like 'test_db' 完全匹配查找名为test_db的数据库 show databases like '%test%' 查找数据库名称中含有test的所有数据库 show databases like 'db%' 查找数据库名称中以db开头的所有数据库 show databases like '%db' 查找数据库名称中以db结尾的所有数据库修改修改数据库语法格式为： ALTER DATABASE [数据库名] { [ DEFAULT ] CHARACTER SET &lt;字符集名&gt; | [ DEFAULT ] COLLATE &lt;校对规则名&gt;}查看数据库的定义声明：show create database 数据库名 实例 mysql&gt; CREATE DATABASE test_db -&gt; DEFAULT CHARACTER SET gb2312 -&gt; DEFAULT COLLATE gb2312_chinese_ci; mysql&gt; SHOW CREATE DATABASE test_db;删除语法格式： DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt; &lt;数据库名&gt;：指定要删除的数据库名。 IF EXISTS：用于防止当数据库不存在时发生错误。 DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。 选择语法格式: use &lt;数据库名&gt;如何查看当前使用的是哪个数据库?有三条语句可以实现。 select database(); show table; status; 引擎设置默认引擎： SET default_storage_engine=&lt; 存储引擎名 &gt;InnoDB 是系统的默认引擎，支持可靠的事务处理。通过上述语句修改后，默认引擎可以改变，但是MySQL重启后，默认引擎依然是InnoDB。 MySQL常见数据类型在MySQL中常见的数据类型如下所示: 1) 整数类型 包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型 FLOAT 和 DOUBLE，定点数类型 DECIMAL。 2) 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 3) 字符串类型 包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 4) 二进制类型 包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 具体数据类型的讲解可以看这儿MySQL常见数据类型 MySQL表相关操作创建其语法格式为： CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];其中，[表定义选项]的格式为： &lt;列名1&gt; &lt;类型1&gt; [,…] &lt;列名n&gt; &lt;类型n&gt;实例 船舰一个员工表，结构如下。 字段名称 数据类型 备注 id INT(ll) 员工编号 name VARCHAR(25) 员工名称 deptld INT(ll) 所在部门编号 salary FLOAT 工资 mysql&gt; USE test_db; Database changed mysql&gt; CREATE TABLE tb_emp1 -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt; ); Query OK, 0 rows affected (0.37 sec)使用show tables语句查看数据表是否创建成功 查看DESCRIBE/DESC 语句可以查看表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法规则如下： DESCRIBE &lt;表名&gt;; 或简写成： DESC &lt;表名&gt;;SHOW CREATE TABLE语句可以用来显示创建表时的CREATE TABLE语句，语法格式如下： SHOW CREATE TABLE &lt;表名&gt;\G；修改常用的语法格式如下： ALTER TABLE &lt;表名&gt; [修改选项] 修改选项的语法格式如下： { ADD COLUMN &lt;列名&gt; &lt;类型&gt; | CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt; | ALTER COLUMN &lt;列名&gt; { SET DEFAULT &lt;默认值&gt; | DROP DEFAULT } | MODIFY COLUMN &lt;列名&gt; &lt;类型&gt; | DROP COLUMN &lt;列名&gt; | RENAME TO &lt;新表名&gt; }添加字段ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]；实例：在第一列添加int类型字段col1 mysql&gt; ALTER TABLE tb_emp1 -&gt; ADD COLUMN col1 INT FIRST; Query OK, 0 rows affected (0.94 sec) Records: 0 Duplicates: 0 Warnings: 0若无 first 或 after，则默认在最后一行添加新字段 修改字段类型ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;删除字段ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；修改字段名称ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；新数据类型指的是修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。 修改表名ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；删除语法格式如下： DROP TABLE [IF EXISTS] &lt;表名&gt; [ , &lt;表名1&gt; , &lt;表名2&gt;] …语法说明如下：1.&lt;表名&gt;：被删除的表名。DROP TABLE 语句可以同时删除多个表，用户必须拥有该命令的权限。2.表被删除时，所有的表数据和表定义会被取消，所以使用本语句要小心。3.表被删除时，用户在该表上的权限并不会自动被删除。4.参数IF EXISTS用于在删除前判断删除的表是否存在，加上该参数后，在删除表的时候，如果表不存在，SQL 语句可以顺利执行，但会发出警告（warning）。 MySQL键约束键约束感觉就是给一些键增加特定的标识，作为这个表的某一种标识的体现。 键约束一共有主键、外键、唯一约束。 主键定义&amp;作用：“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 创建语法： &lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]实例：id int(11) primary key，此时id即成为这个表的主键。 在定义完所有列之后，指定主键的语法格式为： [CONSTRAINT &lt;约束名&gt;] PRIMARY KEY [字段名]实例：primary key(id),此时id即成为这个表的主键。 创建复合主键： PRIMARY KEY [字段1，字段2，…,字段n]实例：primary key(id, deptId),此时id和deptId即成为这个表的复合主键。 修改表时添加主键： ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);实例：ALTER TABLE tb_emp2 ADD PRIMARY KEY(id);，此时添加id成为这个表的主键。 外键定义&amp;作用：MySQL 外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。 创建语法： [CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]实例：CONSTRAINT fk_emp_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id) 修改表时添加外键： ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt; FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);实例： mysql&gt; ALTER TABLE tb_emp2 -&gt; ADD CONSTRAINT fk_tb_dept1 -&gt; FOREIGN KEY(deptId) -&gt; REFERENCES tb_dept1(id);删除外键： ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;实例: mysql&gt; ALTER TABLE tb_emp2 -&gt; DROP FOREIGN KEY fk_tb_dept1;唯一约束定义&amp;作用： MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 创建语法： &lt;字段名&gt; &lt;数据类型&gt; UNIQUE添加唯一约束： ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;);实例： mysql&gt; ALTER TABLE tb_dept1 -&gt; ADD CONSTRAINT unique_name UNIQUE(name); 删除唯一约束： ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;检查约束具体语法: CHECK &lt;表达式&gt; 修改表时添加约束： ALTER TABLE tb_emp7 ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;) 删除约束: ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;; 默认值设置：&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;; 非空约束设置: &lt;字段名&gt; &lt;数据类型&gt; NOT NULL; 选择数据selectselect语句语法： SELECT {* | &lt;字段列名&gt;} [ FROM &lt;表 1&gt;, &lt;表 2&gt;… [WHERE &lt;表达式&gt; [GROUP BY &lt;group by definition&gt; [HAVING &lt;expression&gt; [{&lt;operator&gt; &lt;expression&gt;}…]] [ORDER BY &lt;order by definition&gt;] [LIMIT[&lt;offset&gt;,] &lt;row count&gt;] ]查询表中全部内容，具体格式： SELECT * FROM 表名;查询指定字段，具体格式： SELECT &lt; 列名 &gt; FROM &lt; 表名 &gt;;去重消除重复的记录值，使用关键字distinct,具体语法: SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;;限制查询条数当只需要查询某几行内容时，需要用到关键字llimit，具体格式: &lt;LIMIT&gt; [&lt;位置偏移量&gt;,] &lt;行数&gt;实例1： SELECT * FROM tb_students_info LIMIT 4; 查询的就是1~4行的内容实例2： SELECT * FROM tb_students_info LIMIT 3,5; 查询的就是偏移3行，即4~8行的内容 排序具体格式： ORDER BY {&lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt;} [ASC|DESC]注:关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值。这两个关键字必须位于对应的列名、表达式、列的位置之后。 实例1： SELECT * FROM tb_students_info ORDER BY height;以height为升序排序 实例2： SELECT name,height FROM tb_student_info ORDER BY height DESC,name ASC;先以height为降序排序，然后以name为升序排序 条件查询筛选数据，具体格式： WHERE &lt;查询条件&gt; {&lt;判定运算1&gt;，&lt;判定运算2&gt;，…}判断语法如下:&lt;表达式1&gt;{=|&lt;|&lt;=|&gt;|&gt;=|&lt;=&gt;|&lt;&gt;|！=}&lt;表达式2&gt;&lt;表达式1&gt;[NOT]LIKE&lt;表达式2&gt;&lt;表达式1&gt;[NOT][REGEXP|RLIKE]&lt;表达式2&gt;&lt;表达式1&gt;[NOT]BETWEEN&lt;表达式2&gt;AND&lt;表达式3&gt;&lt;表达式1&gt;IS[NOT]NULL 插入数据 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++解题时的使用技巧]]></title>
    <url>%2F2019%2F09%2F03%2FC-%E8%A7%A3%E9%A2%98%E6%97%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[记录使用C++做CSP题目时用到的一些C中没用过的数据结构和算法 快排sort用法 头文件 #includesort函数可以有两个参数，也可以有三个参数： 排序数组起始位置 排序数组结束为止 排序的方法，确认是升序还是降序，默认缺省情况为升序排序 举例123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;int main(){ int a[20]={2,4,1,23,5,76,0,43,24,65},i; for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+20); for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;} 注意sort函数第二个参数的范围。 下面主要举例讲解三个参数用来解决结构数组排序的问题。 在CSP 17-3-2排队问题中，我用了一个结构体来表示每个同学，其中包含他的学号和位置。我需要sort函数来对他们的位置进行排序，这个时候就需要用到带有三个参数的sort函数了。 结构体声明如下 1234typedef struct stu{ int id; int place;}stu; 第三个参数函数声明如下 1234bool cmp(stu a, stu b){ return a.place &lt; b.place;} 因为我是要对他们的位置进行排序，而且是升序排序。通过修改return 的内容，可以实现对其他方面的排序以及修改排序的升降。 使用方法 1sort(array+1, array+1+n, cmp); 这样就能对结构数组其中的位置信息进行排序了。 栈和队列stack模板类定义在#include中定义示例代码：stack&lt;int&gt; s基本操作如下 操作 作用 s.push(x) 入栈 s.pop() 出栈，注意该操作只删除元素，不返回元素 s.top() 访问栈顶 s.empty() 栈是否为空，为空时返回true s.size() 访问栈的元素个数 queue模板类定义在#include中定义示例代码：queue&lt;int&gt; q基本操作如下 操作 作用 q.push(x) 入队 q.pop() 出队，弹出队列第一个元素，但不会返回其值 q.front() 访问队首元素，即第一个入队的 q.back() 访问队尾元素，即最后一个入队的 q.empty() 判断队空，若为空返回true q.size() 访问队元素个数 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;void stackFunction(){ stack&lt;int&gt; s; //入栈 s.push(1); s.push(2); s.push(3); //栈元素个数 cout&lt;&lt;"size of stack:"&lt;&lt;s.size()&lt;&lt;endl; //栈顶元素 cout&lt;&lt;"top of stack:"&lt;&lt;s.top()&lt;&lt;endl; //出栈 s.pop(); cout&lt;&lt;"after pop, top of stack is:"&lt;&lt;s.top()&lt;&lt;endl; //栈空 if(!s.empty()) cout&lt;&lt;"stack is not empty"&lt;&lt;endl; s.pop(); s.pop(); if(s.empty() ) cout&lt;&lt;"stack is empty now"&lt;&lt;endl;}void queueFunction(){ queue&lt;int&gt; q; //入队 q.push(1); q.push(2); q.push(3); //队首元素 cout&lt;&lt;"front of queue:"&lt;&lt;q.front()&lt;&lt;endl; //队尾元素 cout&lt;&lt;"back of queue:"&lt;&lt;q.back()&lt;&lt;endl; //队长度 cout&lt;&lt;"size of queue:"&lt;&lt;q.size()&lt;&lt;endl; //出队 q.pop(); cout&lt;&lt;"after pop, front of queue is:"&lt;&lt;q.front()&lt;&lt;endl; //队空 if(!q.empty()) cout&lt;&lt;"queue is not empty"&lt;&lt;endl; q.pop(); q.pop(); if(q.empty() ) cout&lt;&lt;"queue is empty now"&lt;&lt;endl;} int main(){ stackFunction(); cout&lt;&lt;endl; queueFunction(); cout&lt;&lt;endl; return 0;} 结果 123456789101112size of stack:3top of stack:3after pop, top of stack is:2stack is not emptystack is empty nowfront of queue:1back of queue:3size of queue:3after pop, front of queue is:2queue is not emptyqueue is empty now document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++, CSP, 数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2019%2F09%2F01%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一直说是要学习Git，但总是一拖再拖。花了不到一天的时间，就把廖老师的Git教程学完了，受益匪浅，接下来可以在GitHub玩耍了233。顺便掌握了一些windows命令行操作，也很有用。 Git的第一步——创建版本库创建版本库 1234567891011$ mkdir &lt;repository name&gt;$ cd &lt;repository name&gt;创建一个目录$ git init （创建一个版本库）Initialized empty Git repository in &lt;当前路径&gt;.git/添加文件到Git仓库，分两步:$ git add &lt;file name&gt;$ git commit -m &lt;message&gt;可以先多次添加，最后一次提交 版本控制版本回退 123456789$ git log$ git log --pretty=oneline显示从最近到最远的提交日志$ git reset --hard HEAD~&lt;num&gt;(往前num个版本)$ git reset --hard &lt;commit id&gt;(前往对应的提交版本)修改HEAD指向的版本，HEAD指向的版本就是当前版本$ git reflog 查看命令历史，以便确定要回到未来的哪个版本 工作区和暂存区 1$ git status 常看状态 管理修改 12$git diff HEAD -- &lt;file name&gt;查看工作区和版本库里面最新版本的区别 撤销修改 12345$ git checkout -- file总之，就是让这个文件回到最近一次git commit或git add时的状态$ git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区 删除文件 1234情况一：将版本库中的删除$ git rm删掉，并且git commit情况二：误删除，需要恢复到版本库中$ git checkout -- test.txt 远程仓库添加远程仓库 12345678$ git remote add origin git@github.com:michaelliao/learngit.git连接远程仓库，github.com：后面接的是自己需要关联的仓库$ git push -u origin master将本地内容推到远程仓库第一次推送master分支的所有内容的命令行需要带 -u此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 从远程仓库克隆到本地 12$ git clone git@github.com:michaelliao/gitskills.git从远程仓库克隆到当前目录下，同样的，github.com：后面接的是自己需要克隆的仓库 分支管理创建与合并分支 1234567891011121314$ git checkout -b &lt;branch name&gt;创建并且切换到该 分支上$ git branch 查看当前分支情况，*对应的是当前所在的分支$ git checkout master切回到主分支$ git merge &lt;branch name&gt;将该分支合并到主分支上$ git branch -d &lt;branch name&gt;删除该分支 解决冲突 123当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log --graph命令可以看到分支合并图。 分支管理策略 1合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支 123修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 Feature分支 12开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作 (由于没有多人协作的项目经验，这一块看的并不是很明白，只能先把小结部分的内容接下来，以后有类似经验了再消化吸收) 123456查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 Rebase 12$git rebase（这个操作也是没有实践不大好理解啊，就先放这儿） 标签管理创建标签 123命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；命令git tag -a &lt;tagname&gt; -m "blablabla..."可以指定标签信息；命令git tag可以查看所有标签。 操作标签 1234命令git push origin &lt;tagname&gt;可以推送一个本地标签；命令git push origin --tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tagname&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。删除远程标签时，需要先删除本地标签。 配置别名这个看完了感觉还是很实用的，可以把一些比较长的命令行给简化拼写。我这刚刚入门，也不知道这么配置完了之后如果有问题，如何再修改回原来的配置，所以就先用着默认指令吧，以后再来修改。 windows下一些命令行操作12345ls dir 当前目录下的文件pwd chdir 显示当前所在的路径cat type &lt;file&gt; 显示文件内容rm del &lt;file&gt; 删除文件cd .. 返回上一级目录 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二暑假总结]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结一下大二暑假做的事儿，展望一下新学期 谈谈这个暑假放假的时间总是这么的快，感觉没做什么事情，假期又已经结束了。这个暑假不同于以前，自己决定在学校待一段时间，多学点东西再回家。虽然可能学的也不是很多，但至少还是有在学习的。所以想总结一下自己都在这个暑假干了些什么吧。 前期（托福课之前） 这段时间的话主要就是在做爬虫项目，学习了如何使用scrapy框架来进行爬虫。首先是通过豆瓣top250来进行练手，然后爬取了两个学术网站。爬取完后将数据存储到mysql数据库中。完成度的话，还有一些不足，比如mysql知识用navicat进行管理，并没有对数据库有更深的学习。而数据库这个方面在其他学习过程中发现应该是计算机知识很重要的一方面，大三还要多加学习。 还做的一些事就是在洛谷上刷题，学习计网，然后当时每天都有花时间背单词。平时锻炼也很多，晚上不是去打篮球就是去健身。这段时间过得还是挺满意的。 中期（托福课阶段） 这期间主要做的就两个事儿吧，1. 上托福课，2. 学习Java 托福课上完了，口语和听力的收获挺大，阅读的话主要还是靠自己来刷，写作其实当时老师讲的我觉得并没有特别清楚吧，这个后面练习的时候再去网上看看总结什么的。 Java主要是跟着菜鸟教程来学的。当时学到了Java包，基本上只是掌握了Java基础语法，后面的一些高级特性还没有深入学习。练习主要是靠LeetCode来刷题练习，算是练Java的使用，以及提高算法能力。Java的话大三上前段时间加紧学习，然后跟进羊哥推荐的开源项目的学习。 这段时间作息开始不是很规律，早上不早起，晚上早睡了睡不着，学习效率并没有很高。 后期（在家) 学习项目做了的就是刷tpo的阅读，做了有个3篇，得分都在21左右，阅读需要提高的地方还有很多。然后就是在leetcode上面刷题了，在探索中找到了“初级算法”，过一下里面的题目，提高一下自己的算法能力。 这一篇博客距离上一篇差不多有一个月了。前中期的学习还经常写一写博客来记录，后期在家就懒了不少，每天学习也不是很多吧。开学了就要开始继续努力，坚持写博客了。 展望一下大三开学了，加权单也贴到了墙上，看着大二的成绩，自己还是挺不满意的吧。跟大一比，退步了50名左右，真的就是在保研的边缘摇晃了。回想大二，感觉自己真的是很懈怠，课程内任务没有好好学，课程外也没有去学一些自己感兴趣的东西到现在了还啥都不会，就不具备一个开发者的思维模式以及能力。 这个暑假看了不少其他优秀的人是如何学习的，以及如何转变自己学习的思维模式，感觉还是受益良多的。仔细看了看大三的课程，课程相比大一大二，反而感觉课程少了不少，但都是专业课，所以要更加用心去学习，去实践。空余的很多时间要多拿来跑一下开源项目，提升一下自己的能力。 九月份任务 TPO刷题，每天2-3h的英语学习时间（不包括背单词的时间，单词每天也要背起来） 9.15号CSP考试，前两周就多花点时间在这个上面，一二题争取用时短，然后全对。第三题可能真的没法儿看懂，看不懂就算了，反正三四题争取一下。 学习一下git，以后也要用到的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:数组题(1)]]></title>
    <url>%2F2019%2F08%2F01%2FLeetCode-%E6%95%B0%E7%BB%84%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[LeetCode刷题记录 26. 删除排序数组中的重复项题目描述(简单)给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 解题思路开始对原地修改有一些疑问, 后来发现直接进行覆盖即可, 就没什么难度了. 注意数组长度为0这种情况. 解题代码12345678910111213class Solution { public int removeDuplicates(int[] nums) { if(nums.length == 0) return 0; int i = 0; for(int j=1; j&lt;nums.length; j++){ if(nums[j]!= nums[i]){ i ++; nums[i] = nums[j]; } } return (i+1); }} 27. 移除元素题目描述(简单)给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element 解题思路 排序 双指针 先对数组进行排序, 然后通过双指针找到等于val的第一个数, 和不等于val的第一个数, 然后进行覆盖 解题代码123456789101112131415161718192021class Solution { public int removeElement(int[] nums, int val) { if(nums.length == 0) return 0; Arrays.sort(nums); int front,tail; for(front=0; front&lt;nums.length; front++) { if(nums[front] == val) break; } for(tail = front; tail&lt;nums.length; tail++) { if(nums[tail] != val) break; } if(tail == nums.length) return front; else { for(; tail&lt;nums.length; tail++) { nums[front] = nums[tail]; front++; } } return front; }} 283. 移动零题目描述(简单)给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes 解题思路先把非0的数挪到前面, 并记录0的个数. 挪完后把后面的数全部置0即可 解题代码1234567891011121314151617class Solution { public void moveZeroes(int[] nums) { int front= 0; int counter = 0; //int [] nums = {0,1,0,3,12}; for(int i=0 ; i&lt;nums.length; i++) { if(nums[i] != 0) { nums[front] = nums[i]; front ++; } else counter++; } for(int i=front; i&lt;nums.length; i++) { nums[i] = 0; } }} 总结前三题刚上手LeetCode, 大部分题目对目前的我有点难度, 所以就从自己比较熟悉的数组开始尝试, 边学习Java的使用, 边提高算法能力. 前三题其实还是挺简单的, 主要是一个原地修改数组不另外开辟空间的要求, 最后用覆盖的方法解决了就好了. 11. 盛最多水的容器题目描述(中等)给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water 解题思路解法一 这个解法可以说相当好像到,就是暴力穷举, 用一个双重循环, 将所有的情况都枚举出来, 取其中的最大值即可. 想是很好想, 但是这个算法的效率却很低, 时间复杂度为O(n^2), 所以在这个题中, 我考虑的就是如何用别的算法来达到降低时间的这个目的. 我先用双重循环试了试它的时间, 最后结果为Java提交记录中的30%, 可见效率之低. 解法二 双指针解法:我是没想出来这个解法, 也是看了官方题解才明白的. 它的思路在于两条线段之间形成的区域面积受制于两条边中较短的边. 其次, 两条边距离越远, 面积越大. 通过放置两个指针, 一头一尾, 记录当前最大面积max. 然后移动较短的指针, 更新最大面积max, 直至头尾指针相遇. 只需要扫描一遍即可找到最大值, 所以时间复杂度为O(n). 这个方法看起来比较简单, 但是我在思考为什么这个算法正确的时候花了不少时间. 也看了很多讨论, 利用数学的论证这个方法的正确性, 最终也算是搞懂了. 思考 我发现对于一个问题啊, 我们特别喜欢用暴力穷举的方法来的到答案, 因为在你穷举的过程中看似吧每种可能都给考虑到了,是最周全的方法,结果也是最可靠的. 但是这种方法就会消耗更多的时间, 并且在问题规模大到一定程度后, 穷举在一定的时间内就是不可能完成的, 所以才会有算法的出现. 个人观点, 算法就是用一定的方法, 避免那些”不必要的”穷举, 只需要对部分内容进行操作, 就可以得到正确的结果的过程. 当然算法并不是说一拍脑子就想出来的, 可能想一个算法的过程会有aha moment, 但是想出来了之后都是要通过数学的证明来确定他的正确性的. 所以说数学这个工具也还是很重要的呢. 解题代码1234567891011public static int maxAreaBetter(int[] height) { int max=0; for(int i=0, j=height.length-1; i&lt;j;) { max = Math.max(max, Math.min(height[i], height[j])*(j-i)); if(height[i] &lt; height[j]) { i++; } else j--; } return max; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark实验：HTTP]]></title>
    <url>%2F2019%2F07%2F21%2FWireshark%E5%AE%9E%E9%AA%8C%EF%BC%9AHTTP%2F</url>
    <content type="text"><![CDATA[掌握HTTP相关，实验内容比较简单，尝试学习中成长。 1.基本HTTP GET/response交互这个实验的本身很简单，就是让你访问一个仅含有一段简单的html代码的网站，然后根据http协议的请求头所包含的信息，来回答问题即可。但是在这个过程中我还遇到了挺多奇奇怪怪的问题。最开始操作不熟练，每次筛选后的到的纪录依然很多，多次尝试后，终于得到了和任务书介绍的类似界面。但是我发现自己的HTTP状态响应为304 Not Modified, 和任务书中的200 OK不同，就很奇怪为什么。当时在下面详情里面看到了If Modified Since, 以及Accept Language。因为不是很明白为什么会出现这种情况，于是就先跳过实验一，看实验二去了。看了实验二才知道，304响应是因为我之前就访问过这个界面，然后浏览器产生了这个网页的缓存，304是说这个界面没有改变的意思。 2.HTTP条件Get/response交互实验二中熟悉操作之后就得到了对应的结果。在检查If-Modified-Since时，发现状态304中出现了这个标识，而且在状态200中，对应的是Last Modified,而且二者时间是一致的。探究If-Modified-Since是何物，网上给到的结果是 意思是我们在请求时会发送给服务器上次它修改这个文件最后一次时间，如果服务器发现仍然没有修改这个文件，就会返回304文件为改变的信息，调用本地caceh缓存，如果改变就会重新得到。 3.检索长文件实验三顺利执行，结果如下图数据信息包含在HTTP响应体里面。由于html文本过长，所以TCP共分了4个帧来存放这些信息，分组情况如下图 4.具有嵌入对象的HTML文档实验四捕获结果如下一共有三个HTTP GET请求，访问的IP地址都是128.119.245.12，按顺序得到了三个内容，分别是：html文件、pearson的图片、以及教材第五版的封面图，由于请求的时间不同，所以判断应该不是并行获得，而是按顺序请求获得。 5.HTTP认证实验五结果如下图最开始登录之后得到的界面是404 Not Found，感觉很奇怪啊，这不应该啊。后来检查了一下仓库中的URL，发现是给的URL打漏了一个”-“，打开正确的URL即可得到正确的结果界面。然后就在issue里面提交了这个问题，觉得Github还是很有意思啊。任务中让我们尝试base64加密方式，在wireshark中会自动解码出来，具体结果如下所示 Authorization: Basic d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=\r\n Credentials: wireshark-students:network上面是加密前，下面是解密后的结果。可见我们的密码并不是很安全，需要别的措施来防止别人窃取。 6.实验收获这个实验还是蛮简单的，具体步骤不知道怎么做或者是不知道要得到什么结果，参照一下Github上的pdf也就很容易解决。相比较第一个Wireshark，这个更加有实际操作的感觉，也锻炼了使用这个工具，继续努力~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>实操纪录</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codesheep笔记:为什么推荐Java而不是C++]]></title>
    <url>%2F2019%2F07%2F19%2Fcodesheep%E7%AC%94%E8%AE%B0-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90java%E8%80%8C%E4%B8%8D%E6%98%AFc%2F</url>
    <content type="text"><![CDATA[java学过很多次，但是每次都没有坚持学下去，觉得没有什么动力，看了羊哥的这个视频，觉得更有必要好好学习Java了。 1.目前的市场情况 互联网服务背后主流驱动技术就是Java，应用广泛 招聘岗位远比其他语言大的多 羊哥的实际感受：C/C++项目经历没有什么连续性，而Java则不一样。虽然业务不同，但编程经验都是一样的，具有较强的连续性。而且随着经验的丰富，可以转换到高级的方向很多 总结：市场表现来看，Java是最好的语言 2.内因：Java本身也很争气Java自身强大与优雅之处： 面向对象。Java是一个纯面向对象的语言，本身就是面向企业开发、大系统来设计的 静态语言。静态语言就有编译过程，在编译过程中可以报错，确保系统安全；其次，静态语言的速度会比动态语言快很多 Java两个最强的技术特性： 跨平台特性。 自动内存管理。 3.Java语言的应用场景和生态J2EE生态丰富完整，拥有很多可靠的开源软件 4.Java新的生命力的注入版本更新迭代快，更多高性能属性不断加入 5.怎么学 Java的基础语法 企业级开发框架：SSM、Spring Boot。数据库学习 书籍推荐 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>codesheep笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络（自顶向下方法）》学习笔记（持续更新）]]></title>
    <url>%2F2019%2F07%2F18%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面暑期实习做网络爬虫相关的事情，对计网有了一定的初步认识，感觉蛮有趣的，想到下学期也要学习计网，所以就准备提前学习了。买了课本，也在MOOC上学习，用博客来记录学习笔记。 实验资料：wireshark实验 1. 计算机网络和因特网1.1 什么是因特网网络：许多计算机连接在一起。 互联网（internet）：许多网络连接在一起。 因特网（Internet）：全球最大的互联网。 ISP（Internet Service Provider）：网络运营商（如移动，联通，电信等）。 端系统、分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接受和发送。TCP(Transmission Control Protocol, 传输控制协议)和IP(Internet Protocol, 网际协议)是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接受的分组格式。因特网的主要协议统称TCP/IP协议。 套接字接口（socket interface）:由与因特网相连的端系统提供，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序员交付数据的方式。因特网套接字接口是一套发送程序必须遵循的规则集合。可以与寄信、送信、收信的流程来类比。 协议：定义了在两个或多个通信实体之间交换的报文和顺序。以及报文发送和/或接受一条报文或其他事件所采取的动作。类比人类之间的交谈。 1.2 网络边缘端系统：与因特网相连的计算机和其他设备的称呼，因为位于因特网的边缘而得名。组成：包括了桌面计算机、服务器和移动计算机。端系统也统称为主机。 以太网（Ethernet）是一种计算机局域网技术，是目前应用最普遍的局域网技术。 1.3 网络核心为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组。在源和目的地之间，每个分组都通过通信链路和分组交换机传送。（交换机主要有两类：路由器和链路层交换机）。多数分组交换机在链路的输入端使用存储转发传输机制。 输出缓存（也称输出队列）：用于存储路由器准备发往那条链路的分组。排队时延：到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。分组丢失（丢包）：一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满，到达的分组或已经排队的分组之一将被丢弃。 1.4 分组交换网中的时延、丢包和吞吐量2. 应用层2.1 应用层协议原理2.2 Web和HTTP2.3 因特网中的电子邮件2.4 DNS:因特网的目录服务2.4.1 DNS提供的服务识别主机有两种方式，通过主机名或者IP地址，需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统DNS（Domain Name System）的主要任务。DNS是： 一个由分层的DNS服务器实现的分布式数据库。 一个使得主机能够查询分布式数据库的应用层协议。提供的其他重要服务： 主机别名。存在别名时，原始名被称为规范主机名。 邮件服务器别名。 负载分配。 2.4.2 工作机理工作过程应用程序需要主机名转换成IP地址 → 调用DNS客户算 → 用户主机上的DNS收到请求后，向网络中发送一个DNS查询报文（请求、回答报文使用UDP数据包经端口53发送） → 收到一个提供所希望映射的DNS回答报文 → 映射结果被传递到调用DNS的应用程序。 最开始的DNS的简单设计是一个DNS服务器，集中式设计存在如下问题：单点故障、通信容量、远距离的集中式数据库、维护。因此DNS采用了分布式的设计方案。 分布式、层次数据库大致讲，共有3种类型的DNS服务器： 根DNS服务器。提供TLD服务器的IP地址。 顶级域（Top-Level Domain, TLD）(DNS)服务器。顶级域（com, org, net, edu, gov）和所有国家的顶级域(uk, fr, ca, jp)都有TLD服务器。提供全为DNS服务器的IP地址。 权威DNS服务器。层次之外还有一种重要的DNS服务器：本地DNS服务器。每个ISP都有一台本地DNS服务器。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。查询方式：理论上讲，查询可以是递归查询也可以是迭代查询。实践中采取如下模式：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。 DNS缓存目的：为了改善时延性能并减少在因特网上到处传输的DNS报文数量。原理：在一个请求链中，当某DNS服务器接收到一个DNS回答时，它能够将映射缓存在本地储存器中。如果在DNS服务器中缓存了一台主机名/IP地址对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址，即使它不是该主机的权威服务器。缓存的信息通常保留两天。 2.4.3 记录和报文pass P2P文件分发套接字编程：生成网络应用本节目的：考察研发一个CS服务器应用程序中的关键问题，将实现一个非常简单的CS服务器应用程序代码 .1 UDP套接字 术语缩写 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七月上半月总结]]></title>
    <url>%2F2019%2F07%2F18%2F%E4%B8%83%E6%9C%88%E4%B8%8A%E5%8D%8A%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[暑假过的时间是真的快啊,感觉还没做些什么七月就已经过半了，想着还是有必要纪录一下这段时间都干了些什么，也算一种成长记录与自我总结反思。 七月上半月我都做了些什么： 暑期实习 学习了scapry框架下爬虫的使用 对论文期刊进行了爬虫实践，将论文信息按照学长给的表格给爬取了下来。 将论文内容存储到mysql数据库。 英语学习 每日背单词 进行了几天的听力训练 计算机网络学习 跟着中国大学mooc上的课程学习。 看《计算机网络（自顶向下方法）》 每日运动 基本上每天都会去健身房或者去球场打球，如果不是很想去，也会在寝室进行一些健身运动。 不足之处： 说好的每天规律作息，其实并没有很好地去完成。每天晚上不是很睡得着，白天就起不来，经常睡到九十点，一个上午就浪费掉了。 爬虫项目目前进度挺慢的，不是很上心。 计网的学习又是受会出现三天打鱼两天晒网的情况，不是很好。 有一段时间没有去洛谷和CSP打代码咯。 评价一下自己上半个月，我觉得基本满意，还有不足需要继续努力。通过做爬虫的实习，开始对计网感兴趣，并自主去学习，我觉得还是很有意思的。健身运动也没停，body building做的还不错，希望能更壮一点。下半个月要开始上托福课了，作息应该会比较规律，要继续努力，越努力越优秀。 下个月要做的事： 抓紧实习项目的进展，不懂得多自我学习解决，实在不会再去麻烦学长。 认真上托福课，不能让钱白花，多自学。 英语背单词不要中断，养成一种习惯。 培养写博客的习惯。搭建自己的博客不是目的，写博客才是最终的需要去做的，坚持学习，坚持输出。 抽时间去oj做做题鸭。 健身再壮一点。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客——hexo搭建以及美化]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面因为刚好想总结一下这段时间的学习到的东西，正在考虑注册个csdn还是简书，看到了羊哥的视频，就心血来潮自己搭了个独立博客，还是很有趣的，希望以后能多多学习多多积累。 搭建过程首先是根据羊哥评论里面一个小伙伴博客的帖子，把前期安装给解决了。然后跟着羊哥（codesheep）的视频把博客部署到了github上去。最后看知乎的一个帖子来美化我的博客。怎么说呢，现在markdown格式什么的也是第一次接触，都挺不熟练的，但是总要迈出第一步的嘛。这一篇就记录一下搭建的过程，有些东西还想补充，但是markdown语法不会，不知道该怎么添加，就以后再加。这几天就把这段时间爬虫的学习经历总结一下，发一篇博客。 图床搭建博客中的图片插入还会一个问题，需要使用到图床，这里采用的是七牛云图床，具体搭建方法参考了这个博客。 刚才还发现markdown格式自己疏忽的地方，在添加“博客”这个链接的时候，通过中括号+小括号，发现并没有像之前的链接会变成蓝色，检查之后，原来是使用了中文括号的缘故。这种问题在编译器里面看都不是很容易察觉，更不用说在这个markdownpad中了，还是要注意一下。 博客发表之前每次发布、修改，都要通过下面三个指令来实现： hexo clean hexo g hexo d之前感觉每次都这么输挺麻烦的，不过好像发布就得这个样子，后期再研究研究。发布之前可以先通过本地的localhost来看一下博客格式是否与自己想法一致，通过输入下面的指令来开启本地hexo服务。 hexo s不过这种方式默认使用的是4000端口，我的本地4000端口好像被占用了，解决这个有两种方法，一个是干掉本地占用4000端口的服务，让hexo来使用。另一种方式就是将hexo服务换一个端口来实现，这里我使用的是5000端口，指令如下。 hexo s -p 5000美化进阶之前就是换了个Next主题，虽然说挺够用的，还是挺简陋的，不够酷，所以找了个教程来配置next主题，先码住，之后再修改。Hexo博客第三方主题next进阶教程一个next基础配置帖子,很受用。 博客再更我突然明白了为什么有现成的博客网站大家不用，而是选择自己搭建博客这种比较麻烦的方式，因为可以自定义。有的人喜欢现成的东西，用起来简单省心，虽然可能有一些自己想有但是没有的功能，或者是用起来不舒服的地方。有的人喜欢自己来定义，虽然比较麻烦，比较操心，但出了什么问题都可以通过自己来解决，就很合自己的心意。就像《食戟之灵》里面的central和幸平他们的争斗，也是如此，为了自由而战。也明白了为什么UDP协议既然是不安全的，都用TCP协议不就好了，因为UDP轻量，方便自己去定制。 markdown的一些语法markdown让文字居中和带颜色 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
  </entry>
</search>
